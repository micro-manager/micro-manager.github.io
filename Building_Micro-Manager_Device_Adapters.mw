* Nenad Amodaj,	 nenad@amodaj.com
* Nico Sturman, 	nico@cmp.ucsf.edu
* Karl Hoover,		karl.hoover@gmail.com

==Introduction==

One of the most powerful features of Micro-Manager is that anyone with average command of C++ programming language can write device adapters (or as some prefer to say “drivers”) for the new hardware, or even improve on existing ones. We chose “device adapter” for micro-manager device modules so that we can use the term “driver” for manufacturer’s native device software components. Micro-manager device adapter performs normalization of various software command sets specific of each manufacturer to an uniform micro-manager interface protocol. This document will introduce tools and workflow protocol for creating device adapters from scratch in the form of the hands-on step by step tutorial.

Let's assume that we are writing a device adapter, for a device called “MyDevice.” The workflow for development of the new adapter should look like this:
* Check out the latest source code from the Micro-Manger SubVersion repository
* If required, install device manufacturer’s drivers, SDK and any other software/hardware required for the particular device we are working with.
* Build test programs from the provided source code
* Create new directories and project files for our new device adapter. In this step we can use some of the provided skeleton or demo adapters as an example or a starting point.
* Write code for controlling the new device and build run-time module. The final result is a dynamically linked library file that conforms to Micro-Manager API and contains one or more newly developed device adapters.
* Run test programs to validate and debug (if necessary) our new adapter. If our new device adapter passes these tests, it is more or less guaranteed to properly load and interact with the Micro-Manager application.
* Download and install the latest version of the Micro-Manager application, drop-in the new dynamic library file (to its installation directory) and do final testing with the full-blown application

==Terminology conventions==

* '''Module''' – denotes run-time software component located in a single file, usually an executable or dynamic library
* '''Device Adapter''' – a class (as in C++) that converts device manufacturer’s command set (or API) to Micro-manager device interface API
* '''Driver''' – one or more software components provided by the device manufacturer to enable other software such as Micro-manager to control the device (some devices do not require drivers)
* '''Library''' – dynamic library (e.g. dll, dylib, so, etc.) conforming Micro-manager module API and naming convention that contains one or more Device Adapters

== Directory Layout ==

Before doing anything else we should check out the latest version of micro-manager from the SubVersion repository to appropriate base directory on our computer. The checkout process is outlined in the next few steps.

First we check out Micro-Manager source code from:

https://valelab.ucsf.edu/svn/micromanager2/trunk/

into directory <code>/projects/micro-manager1.4</code> on our computer. Then we check out required 3rd-party libraries from:

https://valelab.ucsf.edu/svn/3rdpartypublic/

into directory <code>/projects/3rdpartypublic</code> on our computer.

At this point we can install any proprietary drivers or SDKs that may be required by the manufacturer of our hardware. Devices that we intend to control via serial port (RS-232) do not require any drivers. It is probably a good idea to follow whatever is the default location for manufacturer’s driver or SDK and run their software demos afterwards to validate the installation. If we do have to link our code against manufacturer’s proprietary libraries we should copy required files and directories (usually header files and dynamic or static libraries) to the following location:

<code>/projects/3rdparty/MyDevice</code>

Top-level directory can be called something other than “projects”, but within our top-level directory we must have three parallel sub-directories with fixed names:

<code>/micro-manager1.4</code> (development source code)

<code>/3rdpartypublic</code> (required open source 3rd-party libraries)

<code>/3rdparty</code> (optional proprietary libraries that may be required for our hardware)

=== Development Directories and Tools ===

Now that overall directory structure is set, we can have a look at Developer’s Kit tools and also find a place to develop our new “MyDevice” adapter. Development tools are located in:

<code>/projects/micro-manager1.4/DeviceKit</code>

'''LibraryTest''' – command line program to test the micro-manager device Library and list all contained Device Adapters

'''DeviceTest''' – command line program to test a single Device Adapter and list all of the available device properties and features

'''CoreTest''' – command line program to test one or more Device Adapters from one or more Libraries using Micro-manager configuration files

The place designated for development of our new adapter is:

<code>/programs/micro-manager1.4/TestDeviceAdapters</code>

In this directory we will find a very simple “skeleton” camera adapter project “MMCamera” that we can use to get started, to understand the basic principles of Micro-manager API and also use files as template to get started on our own project. All our development projects should be located in “TestDeviceAdapters” directory in the same way as for MMCamera. In our case we will create a new directory for our new Device Adapter:

<code>/programs/micro-manager1.4/TestDeviceAdapters/MyDevice</code>

== Building Test Programs and Camera Adapter Example ==

In contrast to previous versions of the Device Kit we now have to build development tools (test programs) and example Device Adapters from source code. There are no installers to download and run. The advantage of the new source code approach is that Device Kit will always be in sync with the main code base.

In this tutorial we will describe build process for Windows. Linux and Mac developers can use the same source files without any changes (*.cpp and *.h), except for having to create appropriate build files for each platform. Project files are provided only for Microsoft Developer’s Studio 2008 because Micro-manager team uses this version for release builds. We can also use version 2010 with automatic project conversion. 'Express' (free) versions of Visual Studio should also work for x86, to build amd64 native application we’ll need the Professional version of Visual Studio.

First open LibraryTest solution (sln) project file and launch build. If all directories were set as described this project should build without any warnings or errors. You can repeat the same for DeviceTest and CoreTest projects. At this point all our tools are ready for use.

Finally open the MMCamera project and examine its structure and project settings. This is a very simple example that can be used as a template or starting point for new projects.

== Project Settings (Windows)
Micro-manager Device Adapter is a C++ class residing in a Library (dynamically linked). One Library usually contains more than one DeviceAdapter. Micro-manager application does not link against any of the Device Adapter libraries at build time. Libraries are discovered by scanning the application default directory for dynamic libraries following the specific naming convention:

mmgr_dal_<device name>.dll

In other words it will try to load at run-time only libraries with prefix “mmgr_dal”. In our case our new adapter (once we are finished with it) should build as mmgr_dal_mydevice.dll.

In terms of code generation settings, we are linking against C++ run-time multithreaded DLLs (not static ones). The project should be configured to support asynchronous exceptions (/EHa). Typically we don’t use precompiled headers.

Preprocessor macros should include MODULE_EXPORTS definition. This setting is the same for all Micro-manager Libraries.

“../../MMDevice” path should be a part of “Additional include directories”

And finally in “post-build” step we want the target to be copied in a standard run-time location:

/projects/micromanager1.4/bin_win32 (for 32-bit Windows)

or 

/projects/micromanager1.4/x64 (for 64-bit Windows)

Settings described above are required for all Micro-manager adapters. Everything else is determined by the specific requirements of our new device, e.g.  we may have to list other “additional” include and library paths and link against other static or dynamic libraries.

== Plugin interface ==

A device adapter is a software plugin for a specific device, e.g. stage, camera, shutter, etc. Each device adapter must implement one of the abstract interfaces defined in the MMDevice.h. Device library (DLL file) can contain one or more device adapters. The library DLL must also implement plugin management functions defined in the ModuleInterface.h. In theory, these two files plus MMDeviceConstants.h (for error codes and other constants) are all you need to create device adapters: if you implement the required API with the correct behavior, the Micro-Manager application will be able to make use of it.

MMDevice.h, ModuleInterface.h and MMDeviceConstants.h essentially define the plugin interface and are also used by the MMCore module. Do not modify these files – any discrepancy between your version and the one used to build the main application will likely result in the system crash or severe malfunction. 

== Utility classes and files ==

To make building device adapters easier, we provide a couple of additional files to use as building blocks. First, DeviceBase.h contains base class partial API implementations for all device classes. The idea is to derive your particular device adapter class from the appropriate class defined in the DeviceBase.h. This header file contains method implementations as well, so there is no corresponding cpp file.

Since DeviceBase.h and other utility files are not used by the main application, you can modify them if you wish. However, the best strategy is to avoid changing any of the supplied utility files since they implement some of the essential device behavior that the main application is relying on. Also, you should avoid overriding methods in the supplied base classes, even if they are declared as virtual – the class is not really designed for that purpose. The idea is to derive your class from one of the base classes and implement only abstract methods.

Property.h and Property.cpp provide the implementation of the Micro-Manager "Property" mechanism, but again, only on the device side – they are not used in the rest of the application. Property class is used by the DeviceBase classes and most of the time you won't have to deal with it directly.

DeviceUtils.h and DeviceUtils.cpp contain a couple of relatively simple helper functions you may or may not want to use.

ImgBuffer.h and ImgBuffer.cpp provide a simple implementation of the generic image buffer, which you may or may not find useful for building camera adapters. By all means disregard this class if you have a better one or your device does not need to deal with images.

== Device Adapter Examples ==

Before writing a new device adapter, you may find it worthwhile to examine the source code of some of the numerous open source device adapters already written, [https://valelab.ucsf.edu/svn/micromanager2/trunk/DeviceAdapters/ available in our subversion repository]. In addition, a few device adapters are included as examples in the device developer's kit:

=== DemoCamera ===

DemoCamera project included in the installer is a simple example on how to create a working device adapter.  You can use it as a starting point for building your own device adapter. DemoCamera DLL contains a simple monochrome / color camera simulator and a number of demo devices: objective turret, filter changer, stage, image processor etc. The camera adapter is able to simulate parameter read-backs. There is also an option to simulate timeout errors. Most of these devices don't really perform any actions, they just respond to commands and their main purpose is to enable testing of the main application without connecting to the hardware.

DemoCamera.cpp includes relatively extensive comments to help you understand how the API methods should work.

=== Sensicam ===

Sensicam project is also included in the installer as an example of the 'real' camera driver. However, in order to build it you need to obtain Sensicam SDK (header files and libraries) from the camera manufacturer. This driver is relatively limited in functionality; code has very few comments, and should be used only as an example, mainly of how the external camera libraries are used to build the device adapter for Micro-Manager.

=== Nikon ===

Nikon project is an example of the device adapter using serial interface. Micro-Manager adapters should not use serial ports directly, but rather by using system calls provided by the Micro-Manager device API.

=== SimpleAutofocus ===

SimpleAutofocus is a image-metric based autofocus 'adapter' implemented in C++. It is configured in the demo&ImageProc.cfg configuration. This provides a concrete example of how a hardware autofocus device would be interfaced to the system.

== Project settings for MSDEV ==

For M.S. Windows, Micro-Manager C++ code is built with Visual Studio 2008.   Visual Studio 2010 will also work. You can build the x86 natives with the free 'Express' version of Visual Studio. In order to build the amd64 natives you'll need the Professional version of Visual Studio. You should use the same project settings as in the DemoCamera.vcproj or Sensicam.vcproj, unless you have some really strong reason to do otherwise. 

All the project are configured to support asynchronous exceptions.

== Testing and debugging device adapters ==

=== C++ environment ===

Using the included project Module_Test, you can test and debug your device adapter completely within your C++ build environment, without the need to use Java API or even having any reference to the existing Micro-Manager installation. 

=== Scripting environment ===

To test devices from Micro-Manager scripting environment you can use the "Scrip Panel" (Tools menu). The scripting environment has a built-in reference to the main API module as "mmc" and reference to the UI "gui". Here is an example of a simple test script:

 mmc.unloadAllDevices();       
 mmc.loadDevice("Camera", "DemoCamera", "DCam");
 mmc.initializeDevice("Camera");

 mmc.setExposure(50); 
 mmc.snapImage();
			
 if (core.getBytesPerPixel() == 1) {
   // 8-bit grayscale pixels
   byte[] img = (byte[])mmc.getImage();
   gui.message("Image snapped, " + img.length + " pixels total, 8 bits each.");
   guimessage("Pixel [0,0] value = " + img[0]);
 } else if (mmc.getBytesPerPixel() == 2){
   // 16-bit grayscale pixels
   short[] img = (short[])mmc.getImage();
   gui.message("Image snapped, " + img.length + " pixels total, 16 bits each.");
   gui.message("Pixel [0,0] value = " + img[0]);             
 } else {
   gui.message("Dont' know how to handle images with " + mmc.getBytesPerPixel() 
                   " byte pixels.");             
 }

If you plan to actively use scripting you may want to look at the [[Micro-Manager_Programming_Guide]]
as well as at the [[Script_Panel_GUI|Scripting Guide]].

The guide was written for standalone Java programming, but the BeanShell syntax is the same and in principle the examples are more or less applicable to the scripting environment. The main thing to keep in mind is that in Micro-Manager scripting console there is no need to instantiate the "core" module. The reference to the core API is already available as "mmc" object.

== Changes from the previous releases ==

=== API version 38 (1.4.0 release) ===
==== New Core API entries ====
* MM::DeviceDetectionStatus detectDevice(char* deviceName) – for automatic device detection 
* void unloadDevice(const char* label) throw (CMMError) – unload a device adapter
==== Property API changes ====
* int applyProperties(std::vector<PropertySetting>& props, std::string& )
* void updateCoreProperties() throw (CMMError)
* void setProperty(const char* label, const char* propName, …) new entries added which accept bool, long, float, and double.
==== Property sequencing API ====
* bool isPropertySequenceable(const char* label, const char* propName) const throw (CMMError);
* void startPropertySequence(const char* label, const char* propName) const throw (CMMError);
* void stopPropertySequence(const char* label, const char* propName) const throw (CMMError);
* long getPropertySequenceMaxLength(const char* label, const char* propName) const throw (CMMError);
* void loadPropertySequence(const char* label, const char* propName, std::vector<std::string> eventSequence) const throw (CMMError);
* bool debugLogEnabled(void) – access the current log state
* std::string saveLogArchive(void)  &    std::string saveLogArchiveWithPreamble(char* preamble, int length)  - create a gzip of the current system log, optionally prepend some client text
* static void addSearchPath(const char *path) – add path to search for device adapters
* unsigned getNumberOfCameraChannels() const – number of simulaneous channels acquired by the camera.
==== Extensions to metadata API ====
* void* getLastImageMD(Metadata& md) const throw (CMMError);
* void* popNextImageMD(Metadata& md) throw (CMMError);
==== Acquisition context API ====
* void acqBefore() throw (CMMError);
* void acqAfter() throw (CMMError);
* void acqBeforeFrame() throw (CMMError);
* void acqAfterFrame() throw (CMMError);
* void acqBeforeStack() throw (CMMError);
* void acqAfterStack() throw (CMMError);
* template <class T> T* getSpecificDevice(const char* deviceLabel) const throw (CMMError) – retrieve device instance by name.

=== API version 33 (1.3.43 release) ===

* New Device categories 
** ProgrammableIO()
** SLM() ( Projector, Spatial Light Modulator, or Anti-Camera)
** CommandDispatch()
* MMDevice.h changes terminology 
* Channels (in the context of color cameras) become Components, hence:
** GetNumberOfChannels -> GetNumberOfComponents. 
** GetChannelName → GetComponentName
* New method signature for devices 
** PrepareSequenceAcqusition()
* Autofocus devices add methods 
** GetOffset(double &offset)
** SetOffset(double offset)
* Core (in MMDevice.h) new method signatures 
** OnCoordinateUpdate(const Device* caller)
** GetChannelConfigs(std::vector<std::string>& groups)
* CMMCore (in MMCore.h) new signatures 
** void setAutoFocusOffset(double offset) throw (CMMError);
** double getAutoFocusOffset() throw (CMMError);
** std::string getSLMDevice();
** std::string getChannelGroup();
** void setSLMDevice(const char* slmLabel) throw (CMMError);
** void setChannelGroup(const char* channelGroup) throw (CMMError);
* CMMCore support for pixel size calibration and configuration group management.

=== API version 31 (1.3.17 release) ===

* BaseSequenceThread. Implemented basic sequence acquisition functionality in svc() method like calculating number of frames, capturing with the specified interval and etc. 

* CCameraBase
** Implemented virtual function IsCapturing returning true if the acquisition thread is run. If you do not use the BaseSequence thread to implement Sequence acquisition, then you will need to provide your own implementation of this function. 
** Added virtual  ThreadRun() method. This method is called from inside the acquisition thread and implements receiving image data from the camera.
** Added virtual OnThreadExiting() method called from inside the acquisition thread and implements actions necessary to finalize the sequence capturing.  

* CMMCore
** Added isSequenceRunning() method which should be used instead of “Busy()” method of the camera to determine if the camera adapter is executing a sequence of image capturing. Note: normally, camera adapters should not return Busy status while the sequence acquisition thread is running.
** Circular buffer now supports 32-bit images.

=== API version 26 to 30 (1.3.15 release) ===
1.	XYStageDevices.  Default implementations for the functions SetRelativePositionUm(double, double), SetPositionUm(double, double), and GetPositionUm(double) are now provided in DeviceBase.h.  You are encouraged not to override these functions but rather implement the Get and SetPostionSteps.  This allows Micro-Manager to provide a general mechanism to let the use mirror the axis and change axis orientation so that a generalized coordinate system can be used.  Although these implementations are not yet provided for single axis stages we anticipate this to happen soon and encourage you to use the 'PositionSteps' functions as the main entry point in communicating with the actual device

2.	CameraDevice – Added Properties 'TransposeMirrorX', 'TransposeMirrorY', 'TransposeXY', 'TranposeCorrection', that can be used to inform Micro-Manager of the camera orientation.  See https://valelab.ucsf.edu/~nico/MMwiki/index.php/Overview for information on how coordinates and directionality are handled in Micro-Manager

3.	CameraDevice – Changes in Sequence mode: There is now a default implementation for SequenceAcquisition.  You should override this with a better implementation if you can.  Two more overloaded forms of StartSequenceAcquistion have been added with default implementations that should b e implemented where possible (one form does not request a number of images, another adds the  parameter bool stopOnOverflow).  

4.	SignalIODevice – Added the functions SetGateOpen and GetGateOpen that are used to configure IO devices as shutters.  

=== API version 24 to 26 (1.2.15 release) ===

1.	CameraDevice - Made the functions 'int GetBinning()' and 'int SetBinning(int binSize)' mandatory.  GetBinning is used in the Core to adjust pixelSize based on binning. The function 'GetNominalPixelSize' was removed.  

2.	StageDevice - Added the function 'int SetRelativePositionUm(double d)'. A default implementation is provided, however, you are encouraged to override this function (which will be madated some time in the future).

3. 	XYStageDevice - Added function 'int SetRelativePositionUm (double dx, double dy)'.  A default implementation is provided, however, you are encouraged to override this function (which will be madated some time in the future).

4.	MagnifierDevice - This is a new device that should be used by devices that effect the magnification in a predictable way.  A single method needs to be implemented for such a device: 'double GetMagnification()'

=== API version 20 to 24 (1.2 release) ===

==== New methods for the base MMDevice class ====
* HasProperty() – for finding out if device supports a property before using it. This will avoid generating and handling exceptions if the desired property does not exist. Default implementation is in the DeviceBase.h, automatic and requires no overriding.
* GetPropertyType() – returns property type. Default implementation is in the DeviceBase.h, automatic and requires no overriding.
* UsesDelay() – Default implementation returns “false”, i.e. declaring that the device does not use “Delay” setting. If the particular adapter does use delay settings, it must override this method by returning “true”. Very few devices use this feature.
* HasPropertyLimits(), GetPropertyLowerLimit(), GetPropertyUpperLimit() – This set of methods allows the device to specify value limits for “continuous” settings. The default implementation of these methods is automatic, but the limits (if any) must be specified in the code when particular property is declared using SetPropertyLimits(). For an example see DemoStreamingCamera.cpp.

==== New device types ====
* ImageStreamer, ImageProcessor and SignalIO device types were added. Instances of these devices are still under development and the API is likely to change. 

We do not recommend writing adapters for these device types just as yet.

=== API version 14 to 20 (1.1 release) ===
New device type
Processor virtual device is added to the MMDevice API to enable real-time processing and closed loop control.
Continuous (burst) acquisition mode
Camera API was extended to optionally support continuous acquisition mode. This mode allows cameras to run at full speed, under their own timing. Additional extensions were also made in the CoreCallback API to provide access to the circular buffer service.
MMTime utility class
A new utility class MMTime was added to simplify cross-platform high-resolution timer functionality, for time-out loops, time stamps, etc.

=== API version 12 to 14 ===
This section is very important if you already have custom adapters for the previous API revision. Your existing adapters won't work with the newer Micro-Manager releases if you don't make changes listed below.
DLL naming convention
All adapter DLL file names now have prefix "mmgr_dal_", e.g. mmgr_dal_hamamatsu.dll. However, there are no changes required for the configuration files. The prefix is internally appended by the MMCore when looking for the device adapter and it does not appear in any external naming convention.

Example project files in this package are all updated with the new convention.  The linker will add prefix to the output file name. You need to modify your existing projects to conform to the new file naming convention.

Additional methods required in all adapter modules
All adapter modules (DLL libraries) now support additional methods (see ModuleInterface.h):

 extern "C" {
    MODULE_API MM::Device* CreateDevice(const char* name);
    MODULE_API void DeleteDevice(MM::Device* pDevice);
    MODULE_API long GetModuleVersion();
    MODULE_API long GetDeviceInterfaceVersion();
    MODULE_API unsigned GetNumberOfDevices();
    MODULE_API bool GetDeviceName(unsigned deviceIndex, char* name, unsigned bufferLength);
    MODULE_API bool GetDeviceDescription(unsigned deviceIndex, char* name, unsigned bufferLength);
    MODULE_API void InitializeModuleData();
 }

The only thing you need to add to your existing modules is the implementation of the method "InitializeModuleData()" (see example projects). This method will be called each time MMCore loads the adapter library. In this method we create a list of adapters available in the DLL library. For example, DemoCamera library (DemoCamera.cpp) has the following InitializeModuleData() method implementation:

 MODULE_API void InitializeModuleData()
 {
    AddAvailableDeviceName(g_CameraDeviceName, "Demo camera");
    AddAvailableDeviceName(g_WheelDeviceName, "Demo filter wheel");
    AddAvailableDeviceName(g_ObjectiveDeviceName, "Demo objective turret");
    AddAvailableDeviceName(g_StageDeviceName, "Demo stage");
    AddAvailableDeviceName(g_LightPathDeviceName, "Demo light path");
 }

The first parameter in "AddAvailableDeviceName", is the adapter name and the second one is a short description.



{{Devices_Sidebar}}
