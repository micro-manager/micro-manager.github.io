__NOTOC__
= Introduction =

To create a device adapter you don't need access to the entire Micro-Manager source code. All files required to build new device adapters for Micro-Manager on the Windows platform are included in the MMDeviceKit-win installer. For devices with special drivers and hardware boards, e.g. cameras, you will need to also install manufacturer's SDK and all required low-level drivers and libraries.

Once you build a device adapter DLL you can just copy it in the Micro-Manager root application directory and load it either from the script (program) or from the configuration file (see Configuration Guide).

= Plugin interface =

A device adapter is a software plugin for a specific device, e.g. stage, camera, shutter, etc. Each device adapter must implement one of the abstract interfaces defined in the '''MMDevice.h'''. Device library (DLL file) can contain one or more device adapters. The library DLL must also implement plugin management functions defined in the '''ModuleInterface.h'''. In theory, these two files plus '''MMDeviceConstants.h''' (for error codes and other constants) are all you need to create device adapters: if you implement the required API with the correct behavior, the Micro-Manager application will be able to make use of it.

'''MMDevice.h, ModuleInterface.h''' and '''MMDeviceConstants.h''' essentially define the plugin interface and are also used by the MMCore module. Do not modify these files ï¿½ any discrepancy between your version and the one used to build the main application will likely result in the system crash or severe malfunction.

= Utility classes and files =

To make building device adapters easier, we provide a couple of additional files to use as building blocks. First, '''DeviceBase.h''' contains base class partial API implementations for all device classes. The idea is to derive your particular device adapter class from the appropriate class defined in the DeviceBase.h. This header file contains method implementations as well, so there is no corresponding cpp file.

Since '''DeviceBase.h''' and other utility files are not used by the main application, you can modify them if you wish. However, the best strategy is to avoid changing any of the supplied utility files since they implement some of the essential device behavior that the main application is relying on. Also, you should avoid overriding methods in the supplied base classes, even if they are declared as virtual ï¿½ the class is not really designed for that purpose. The idea is to derive your class from one of the base classes and implement only abstract methods.

'''Property.h''' and '''Property.cpp''' provide the implementation of the Micro-Manager "Property" mechanism, but again, only on the device side ï¿½ they are not used in the rest of the application. Property class is used by the DeviceBase classes and most of the time you won't have to deal with it directly.

'''DeviceUtils.h''' and '''DeviceUtils.cpp '''contain a couple of relatively simple helper functions you may or may not want to use.

'''ImgBuffer.h''' and '''ImgBuffer.cpp''' provide a simple implementation of the generic image buffer, which you may or may not find useful for building camera adapters. By all means disregard this class if you have a better one or your device does not need to deal with images.

= DemoCamera =

DemoCamera project included in the installer is a simple example on how to create a working device adapter. You can use it as a starting point for building your own device adapter. DemoCamera DLL contains a simple camera simulator and a number of demo devices: objective turret, filter changer, stage, etc. Most of these devices don't really perform any actions, they just respond to commands and their main purpose is to enable testing of the main application without connecting to the hardware.

'''DemoCamera.cpp''' includes relatively extensive comments to help you understand how the API methods should work.

= Sensicam =

Sensicam project is also included in the installer as an example of the 'real' camera driver. However, in order to build it you need to obtain Sensicam SDK (header files and libraries) from the camera manufacturer. This driver is relatively limited in functionality; code has very few comments, and should be used only as an example, mainly of how the external camera libraries are used to build the device adapter for Micro-Manager.

= Nikon =

Nikon project is an example of the device adapter using serial interface. Micro-Manager adapters should not use serial ports directly, but rather by using system calls provided by the Micro-Manager device API.

= Project settings for MSDEV =

All Micro-Manager C++ code is built with MSDEV 8.0 (Visual Studio 2005). You should use the same project settings as in the '''DemoCamera.vcproj''' or '''Sensicam.vcproj''', unless you have some really strong reason to do otherwise.

= Testing and debugging device adapters =

== C++ environment ==

Using the included project Test_MMCore_devkit, you can test and debug your device adapter completely within your C++ build environment, without the need to use Java API or even having any reference to the existing Micro-Manager installation. Test_MMCore_devkit is also an example how you can build C++ applications with MMCore automated microscope API.

Test_MMCore_devkit.cpp is a command line program which takes a configuration file and performs a simple exercise of the API functionality. It links to two pre-built libraries (included in the installation) mmcorer.lib (MMCore API module as static library) and ace.lib (ACE dynamic library).

== Scripting environment ==

To test devices from Micro-Manager scripting environment you can use "Scripting Console" (Tools menu). The scripting environment has a built-in reference to the main API module as "mmc" and log output as "console". Here is an example of a simple test script:

   mmc.unloadAllDevices(); 
   mmc.loadDevice("Camera", "DemoCamera", "DCam");
   mmc.initializeDevice("Camera");
   
   mmc.setExposure(50);

   mmc.snapImage();

   if (core.getBytesPerPixel() == 1) {
     // 8-bit grayscale pixels
     byte[] img = (byte[])mmc.getImage();

     console.message("Image snapped, " + img.length + " pixels total, 8 bits each.");
     console.message("Pixel [0,0] value = " + img[0]);
   } else if (mmc.getBytesPerPixel() == 2){

     // 16-bit grayscale pixels

     short[] img = (short[])mmc.getImage();
     console.message("Image snapped, " + img.length + " pixels total, 16 bits each.");

     console.message("Pixel [0,0] value = " + img[0]); 

   } else {

     console.message("Dont' know how to handle images with " + mmc.getBytesPerPixel() +
     " byte pixels."); 
   }


If you plan to actively use scripting you may want to look at the [[Micro-Manager Programming Guide]].

The guide was written for standalone Java programming, but the BeanShell syntax is the same and in principle the examples are more or less applicable to the scripting environment. The main thing to keep in mind is that in Micro-Manager scripting console there is no need to instantiate the "core" module. The reference to the core API is already available as "mmc" object.

= Changes from the previous releases =

== API version 14 to 20 (1.1 release) ==

=== New device type ===

'''Processor''' virtual device is added to the MMDevice API to enable real-time processing and closed loop control.

=== Continuous (burst) acquisition mode ===

Camera API was extended to optionally support continuous acquisition mode. This mode allows cameras to run at full speed, under their own timing. Additional extensions were also made in the CoreCallback API to provide access to the circular buffer service.

=== MMTime utility class ===

A new utility class MMTime was added to simplify cross-platform high-resolution timer functionality, for time-out loops, time stamps, etc.

== API version 12 to 14 ==

This section is very important if you already have custom adapters for the previous API revision. Your existing adapters won't work with the newer Micro-Manager releases if you don't make changes listed below.

=== DLL naming convention ===

All adapter DLL file names now have prefix "mmgr_dal_", e.g. mmgr_dal_hamamatsu.dll. However, there are no changes required for the configuration files. The prefix is internally appended by the MMCore when looking for the device adapter and it does not appear in any external naming convention.

Example project files in this package are all updated with the new convention. The linker will add prefix to the output file name. You need to modify your existing projects to conform to the new file naming convention.

=== Additional methods required in all adapter modules ===

All adapter modules (DLL libraries) now support additional methods (see ModuleInterface.h):

   extern "C" {
     MODULE_API MM::Device* CreateDevice(const char<nowiki>* name);</nowiki>
     MODULE_API void DeleteDevice(MM::Device* pDevice);
     MODULE_API long GetModuleVersion();
     MODULE_API long GetDeviceInterfaceVersion();
     MODULE_API unsigned GetNumberOfDevices();
     MODULE_API bool GetDeviceName(unsigned deviceIndex, char* name, unsigned bufferLength);
     MODULE_API bool GetDeviceDescription(unsigned deviceIndex, char* name,
                                          unsigned bufferLength);
     MODULE_API void InitializeModuleData();
   }

The only thing you need to add to your existing modules is the implementation of the method "InitializeModuleData()" (see example projects). This method will be called each time MMCore loads the adapter library. In this method we create a list of adapters available in the DLL library. For example, DemoCamera library (DemoCamera.cpp) has the following InitializeModuleData() method implementation:

   MODULE_API void InitializeModuleData()
   {
      AddAvailableDeviceName(g_CameraDeviceName, "Demo camera");
      AddAvailableDeviceName(g_WheelDeviceName, "Demo filter wheel");
      AddAvailableDeviceName(g_ObjectiveDeviceName, "Demo objective turret");
      AddAvailableDeviceName(g_StageDeviceName, "Demo stage");
      AddAvailableDeviceName(g_LightPathDeviceName, "Demo light path");
   }

The first parameter in "AddAvailableDeviceName", is the adapter name and the second one is a short description.


{{Devices_Sidebar}}
