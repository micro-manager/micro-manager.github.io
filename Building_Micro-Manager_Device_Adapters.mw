* Nenad Amodaj,	 nenad@amodaj.com
* Nico Sturman, 	nico@cmp.ucsf.edu
* Karl Hoover,		karl.hoover@gmail.com

==Introduction==

One of the most powerful features of Micro-Manager is that anyone with average command of C++ programming language can write device adapters (or as some prefer to say “drivers”) for the new hardware, or even improve on existing ones. We chose “device adapter” for micro-manager device modules so that we can use the term “driver” for manufacturer’s native device software components. Micro-manager device adapter performs normalization of various software command sets specific of each manufacturer to an uniform micro-manager interface protocol. This document will introduce tools and workflow protocol for creating device adapters from scratch in the form of the hands-on step by step tutorial.

Let's assume that we are writing a device adapter, for a device called “MyDevice.” The workflow for development of the new adapter should look like this:
* Check out the latest source code from the Micro-Manger SubVersion repository
* If required, install device manufacturer’s drivers, SDK and any other software/hardware required for the particular device we are working with.
* Build test programs from the provided source code
* Create new directories and project files for our new device adapter. In this step we can use some of the provided skeleton or demo adapters as an example or a starting point.
* Write code for controlling the new device and build run-time module. The final result is a dynamically linked library file that conforms to Micro-Manager API and contains one or more newly developed device adapters.
* Run test programs to validate and debug (if necessary) our new adapter. If our new device adapter passes these tests, it is more or less guaranteed to properly load and interact with the Micro-Manager application.
* Download and install the latest version of the Micro-Manager application, drop-in the new dynamic library file (to its installation directory) and do final testing with the full-blown application

==Terminology conventions==

* '''Module''' – denotes run-time software component located in a single file, usually an executable or dynamic library
* '''Device Adapter''' – a class (as in C++) that converts device manufacturer’s command set (or API) to Micro-manager device interface API
* '''Driver''' – one or more software components provided by the device manufacturer to enable other software such as Micro-manager to control the device (some devices do not require drivers)
* '''Library''' – dynamic library (e.g. dll, dylib, so, etc.) conforming Micro-manager module API and naming convention that contains one or more Device Adapters

== Directory layout ==

Before doing anything else we should check out the latest version of micro-manager from the SubVersion repository to appropriate base directory on our computer. The checkout process is outlined in the next few steps.

First we check out Micro-Manager source code from:

https://valelab.ucsf.edu/svn/micromanager2/trunk/

into directory <code>/projects/micro-manager1.4</code> on our computer. Then we check out required 3rd-party libraries from:

https://valelab.ucsf.edu/svn/3rdpartypublic/

into directory <code>/projects/3rdpartypublic</code> on our computer.

At this point we can install any proprietary drivers or SDKs that may be required by the manufacturer of our hardware. Devices that we intend to control via serial port (RS-232) do not require any drivers. It is probably a good idea to follow whatever is the default location for manufacturer’s driver or SDK and run their software demos afterwards to validate the installation. If we do have to link our code against manufacturer’s proprietary libraries we should copy required files and directories (usually header files and dynamic or static libraries) to the following location:

<code>/projects/3rdparty/MyDevice</code>

Top-level directory can be called something other than “projects”, but within our top-level directory we must have three parallel sub-directories with fixed names:

<code>/micro-manager1.4</code> (development source code)

<code>/3rdpartypublic</code> (required open source 3rd-party libraries)

<code>/3rdparty</code> (optional proprietary libraries that may be required for our hardware)

=== Development directories and tools ===

Now that overall directory structure is set, we can have a look at Developer’s Kit tools and also find a place to develop our new “MyDevice” adapter. Development tools are located in:

<code>/projects/micro-manager1.4/DeviceKit</code>

'''LibraryTest''' – command line program to test the micro-manager device Library and list all contained Device Adapters

'''DeviceTest''' – command line program to test a single Device Adapter and list all of the available device properties and features

'''CoreTest''' – command line program to test one or more Device Adapters from one or more Libraries using Micro-manager configuration files

The place designated for development of our new adapter is:

<code>/programs/micro-manager1.4/TestDeviceAdapters</code>

In this directory we will find a very simple “skeleton” camera adapter project “MMCamera” that we can use to get started, to understand the basic principles of Micro-manager API and also use files as template to get started on our own project. All our development projects should be located in “TestDeviceAdapters” directory in the same way as for MMCamera. In our case we will create a new directory for our new Device Adapter:

<code>/programs/micro-manager1.4/TestDeviceAdapters/MyDevice</code>

== Building test programs and examples ==

In contrast to previous versions of the Device Kit we now have to build development tools (test programs) and example Device Adapters from source code. There are no installers to download and run. The advantage of the new source code approach is that Device Kit will always be in sync with the main code base.

In this tutorial we will describe build process for Windows. Linux and Mac developers can use the same source files without any changes (*.cpp and *.h), except for having to create appropriate build files for each platform. Project files are provided only for Microsoft Developer’s Studio 2008 because Micro-manager team uses this version for release builds. We can also use version 2010 with automatic project conversion. 'Express' (free) versions of Visual Studio should also work for x86, to build amd64 native application we’ll need the Professional version of Visual Studio.

First open '''LibraryTest''' solution (sln) project file and launch build. If all directories were set as described this project should build without any warnings or errors. You can repeat the same for '''DeviceTest''' and '''CoreTest''' projects. At this point all our tools are ready for use.

Finally open the '''MMCamera''' project and examine its structure and project settings. This is a very simple example that can be used as a template or starting point for new projects.

== Project settings (Windows) ==
Micro-manager Device Adapter is a C++ class residing in a Library (dynamically linked). One Library usually contains more than one DeviceAdapter. Micro-manager application does not link against any of the Device Adapter libraries at build time. Libraries are discovered by scanning the application default directory for dynamic libraries following the specific naming convention:

<code>mmgr_dal_<device name>.dll</code>

In other words it will try to load at run-time only libraries with prefix “mmgr_dal”. In our case our new adapter (once we are finished with it) should build as <code>mmgr_dal_mydevice.dll</code>.

In terms of code generation settings, we are linking against C++ run-time multithreaded DLLs (not static ones). The project should be configured to support asynchronous exceptions (/EHa). Typically we don’t use precompiled headers.

Preprocessor macros should include MODULE_EXPORTS definition. This setting is the same for all Micro-manager Libraries.

<code>../../MMDevice</code> path should be a part of ''Additional include directories'' field.

And finally in ''Post-build'' step we want the target to be copied in a standard run-time location:

<code>/projects/micromanager1.4/bin_win32</code> (for 32-bit Windows)

or 

<code>/projects/micromanager1.4/x64</code> (for 64-bit Windows)

Settings described above are required for all Micro-manager adapters. Everything else is determined by the specific requirements of our new device, e.g.  we may have to list other ''additional'' include and library paths and link against other static or dynamic libraries.

== Device Adapter design ==
=== Plugin interface ===

Plug-in interface along with utility classes is contained in single directory:

<code>/projects/micromanager1.4/MMDevice</code>

Device adapters and Libraries have dependencies only to files in this directory and never include or refer to files from other parts of the Micro-manager code base. There are no libraries to link to, all required code to implement this API is contained either in header files or in the associated *.cpp source files in '''MMDevice''' directory.

A device adapter is a C++ class for controlling one specific device, e.g. stage, camera, shutter, etc. Each device adapter must implement one of the abstract interfaces defined in the '''MMDevice.h'''. Device Library (dynamic library) can contain one or more device adapters. The Library module must also implement plug-in API defined in the '''ModuleInterface.h''' in order to be loaded by Micro-manager applications. In theory, these two files plus '''MMDeviceConstants.h''' (for error codes and other constants) are all we need to create device adapters: if you implement the required API with the correct behavior, the Micro-Manager application will be able to make use of it.

'''MMDevice.h, ModuleInterface.h and MMDeviceConstants.h''' essentially define the plug-in interface and are also used by the Micro-manager application. We should never modify these files – any discrepancy between your version and the one used to build the main application will likely result in the system crash or severe malfunction

=== Utility classes and files ===

To make building device adapters easier, we provide a couple of additional files to use as building blocks. First, '''DeviceBase.h''' contains base class partial API implementations for all device classes. The idea is to derive our particular device adapter class from the appropriate class defined in the '''DeviceBase.h'''. This header file contains method implementations as well, so there is no corresponding cpp file.

Since '''DeviceBase.h''' and other utility files are not used by the main application, you can modify them if you wish. However, the best strategy is to avoid changing any of the supplied utility files since they implement some of the essential device behavior that the main application is relying on.

'''Property.h''' and '''Property.cpp''' provide the implementation of the Micro-Manager "Property" mechanism, but again, only on the device side – they are not used in the rest of the application. Property class is used by the '''DeviceBase.h''' classes and most of the time you won't have to deal with it directly.

'''DeviceUtils.h''' and '''DeviceUtils.cpp''' contain a couple of relatively simple helper functions we may or may not want to use.

'''ImgBuffer.h''' and '''ImgBuffer.cpp''' provide a simple implementation of the generic image buffer, which you may or may not find useful for building camera adapters. We can disregard this class if we have a better one or if our device does not need to deal with images.


== Anatomy of a Device Adapter ==

This section outlines guidelines for designing a well-behaved Device Adapter. MMCamera project included in the Device Kit is a very simple example that can be used to follow the outline.

=== Constructor and destructor ===

Besides ensuring that all member variables get initialized in the constructor and all resources released in destructor, there are a couple of important guidelines to follow with respect to Micro-manager run time environment.

First rule is that we should not communicate with the hardware either in the constructor nor destructor. Connection to the hardware should be established in the Initialize(0 method and terminated in Release(). Constructor and destructor should be designed in such way that creating and destroying an instance of the Device Adapter class (without initializing) carries low overhead and that create/destroy sequence can be repeated multiple times without any effect on the hardware.

Second rule is to use constructor to create and set any device properties that are independent of hardware, such as description strings, adapter name, etc. The concept of properties is explained in detail in the Properties section below.

The third rule is to use constructor to create properties that are required for proper initialization of the hardware. The best example for this is the serial port property. In order to communicate with the hardware device adapter needs to know the serial port (COM port) name that device is attached to. When implementing Initialize() method which establishes the initial communication with the hardware, we already must know the serial port name. Therefore, this property and its value assignment must happen before Initialize() method is called. Such properties that are required to have their values determined before initialization are called “pre-initialization” properties.

=== Initialize() and Shutdown() methods ===

Initialize() and Shudown() methods are critical to ensure that Device Adapter behaves as expected within Micro-manager environment. Rules for implementing these two methods are as follows:
•	Device Adapter instance does not communicate with hardware before Intialize() is called for the first time
•	Intialize() establishes the connection with the hardware and makes device ready to accept commands
•	Once the device is successfully initialized, repeated calls to Initialize() (if they occur) should have no effect
•	Shutdown() disconnects Device Adapter from the hardware and practically reverses the effect of Initialize()
•	Once the device is successfully shut down, repeated calls to Shutdown() should not have any effect
•	After Shudown() is called device should never attempt to communicate with the hardware, except if the Intitalize() is called again

=== Device Types, Names and Labels ===

Device Type is defined by one of the abstract classes contained in MMDevice.h. Each abstract device class implements an API corresponding to various physical hardware devices, e.g. filter wheels, stages, shutters, cameras, etc. We should pick a device type class that is a best match for our hardware device. Sometimes we have to use multiple device types for the same hardware unit, e.g. motorized microscope. In that case we would provide multiple Device Adapter classes that are at run-time connected to the same controller (or Hub) device.

Device Name within Micro-manager should be understood as something akin to a class name in C++. It does not have to be the same as the actual class name, but for all practical purposes it serves as such. It has to be unique within one Library. Micro-manager run-time environment creates instances of Device Adapters by providing the Device Name to the Library which acts as a class factory. The Library looks up the name, instantiates the corresponding C++ class and returns the pointer to the Device Adapter instance.

Device labels are run-time names assigned by the application to each instance, regardless of the actual Device Adapter class. Labels are used as handles for accessing any Device Adapter instance. Typically users assign labels to instances of their devices and the only rule is that they must be unique for each device. So if we equate Device Name as an equivalent of a “class”, a Label would be equivalent to “pointer”.

=== Properties ===

Property mechanism allows the developer to customize settings and behavior of each new Device Adapter. While MM::Device API represents minimal functionality for each device type, is specified in advance and must be implemented by each Device Adapter class, properties are not prescribed and we can have as many or as few as we deem appropriate for controlling our hardware.

Each Device Adapter class can have zero or more properties. Each property is a simple name-value pair. At run-time the application assigns values to properties in one of the three ways: in the configuration process, interactively through the GUI, or by running

== Instance management ==

Micro-manager API in principle allows for multiple instances of the same Device Adapter, i.e. there may be multiple objects carrying the same Device Name. However, depending on the particular device and implementation, multiple instances of the same Device Adapter may or may not make sense. It is the responsibility of the library to either manage instances and any global data that may be shared between them.

Often in case of implementing a Library with multiple devices that are practically identical, we are faced with a design decision regarding instance management. How are we going to distinguish instances within our library since each class instance actually corresponds to a very specific physical hardware device?

=== Multiple independent devices ===

The simplest case is if we just have multiple identical devices all independently attached to the host computer. For example we have one or more filter changers each attached to a separate COM port. We create a single class “MyFilterChanger” derived from the StateDeviceBase class and provide a property called “Port” which should be set at the actual port device is attached to. At run-time Micro-manager application can create any number of instances of the MyFilterChanger class and everything work fine as long each one is assigned a different COM port.

=== Application Layer Services (Core Callbacks) ===

Device Adapter classes are typically derived from appropriate base classes which provide default behavior and various utility methods. But besides base-class inherited methods, Device Adapters also use functionality provided by the parent application. We refer to these application layer services as “callbacks”. The API for callback methods is defined in MMDevice.h in the abstract class MM::Core. At-run time each Device Adapter can obtain a pointer to the instance of the MM::Core interface and use any of the methods provided by it.

=== Threads ===

A minimal, cross-platform set of thread management utilities is provided in MMThreads.h to make Device Adapter implementation easier. Any other thread management library can be used instead. For devices that can in principle run on different operating systems we recommend avoiding native, platform specific thread functions.

== Device Adapter Examples ==

Before writing a new device adapter, you may find it worthwhile to examine the source code of some of the numerous open source device adapters already written, [https://valelab.ucsf.edu/svn/micromanager2/trunk/DeviceAdapters/ available in our subversion repository]. In addition, a few device adapters are included as examples in the device developer's kit:

=== DemoCamera ===

DemoCamera project included in the installer is a simple example on how to create a working device adapter.  You can use it as a starting point for building your own device adapter. DemoCamera DLL contains a simple monochrome / color camera simulator and a number of demo devices: objective turret, filter changer, stage, image processor etc. The camera adapter is able to simulate parameter read-backs. There is also an option to simulate timeout errors. Most of these devices don't really perform any actions, they just respond to commands and their main purpose is to enable testing of the main application without connecting to the hardware.

DemoCamera.cpp includes relatively extensive comments to help you understand how the API methods should work.

=== Sensicam ===

Sensicam project is also included in the installer as an example of the 'real' camera driver. However, in order to build it you need to obtain Sensicam SDK (header files and libraries) from the camera manufacturer. This driver is relatively limited in functionality; code has very few comments, and should be used only as an example, mainly of how the external camera libraries are used to build the device adapter for Micro-Manager.

=== Nikon ===

Nikon project is an example of the device adapter using serial interface. Micro-Manager adapters should not use serial ports directly, but rather by using system calls provided by the Micro-Manager device API.

=== SimpleAutofocus ===

SimpleAutofocus is a image-metric based autofocus 'adapter' implemented in C++. It is configured in the demo&ImageProc.cfg configuration. This provides a concrete example of how a hardware autofocus device would be interfaced to the system.

== Testing and debugging device adapters ==

=== C++ environment ===

Using the included testing tools '''LibraryTest''', '''DeviceTest''' and '''CoreTest''' (see section [[#Building test programs and examples | Building test programs and examples]]) you can test and debug your device adapter completely within your C++ build environment, without the need to use Java API or even having any reference to the existing Micro-Manager installation.

=== Scripting environment ===

To test devices from Micro-Manager scripting environment you can use the "Scrip Panel" (Tools menu). The scripting environment has a built-in reference to the main API module as "mmc" and reference to the UI "gui". Here is an example of a simple test script:

 mmc.unloadAllDevices();       
 mmc.loadDevice("Camera", "DemoCamera", "DCam");
 mmc.initializeDevice("Camera");

 mmc.setExposure(50); 
 mmc.snapImage();
			
 if (core.getBytesPerPixel() == 1) {
   // 8-bit grayscale pixels
   byte[] img = (byte[])mmc.getImage();
   gui.message("Image snapped, " + img.length + " pixels total, 8 bits each.");
   guimessage("Pixel [0,0] value = " + img[0]);
 } else if (mmc.getBytesPerPixel() == 2){
   // 16-bit grayscale pixels
   short[] img = (short[])mmc.getImage();
   gui.message("Image snapped, " + img.length + " pixels total, 16 bits each.");
   gui.message("Pixel [0,0] value = " + img[0]);             
 } else {
   gui.message("Dont' know how to handle images with " + mmc.getBytesPerPixel() 
                   " byte pixels.");             
 }

If you plan to actively use scripting you may want to look at the [[Micro-Manager_Programming_Guide]]
as well as at the [[Script_Panel_GUI|Scripting Guide]].

The guide was written for standalone Java programming, but the BeanShell syntax is the same and in principle the examples are more or less applicable to the scripting environment. The main thing to keep in mind is that in Micro-Manager scripting console there is no need to instantiate the "core" module. The reference to the core API is already available as "mmc" object.

== Changes from the previous releases ==

=== API version 38 (1.4.0 release) ===
==== New Core API entries ====
* MM::DeviceDetectionStatus detectDevice(char* deviceName) – for automatic device detection 
* void unloadDevice(const char* label) throw (CMMError) – unload a device adapter
==== Property API changes ====
* int applyProperties(std::vector<PropertySetting>& props, std::string& )
* void updateCoreProperties() throw (CMMError)
* void setProperty(const char* label, const char* propName, …) new entries added which accept bool, long, float, and double.
==== Property sequencing API ====
* bool isPropertySequenceable(const char* label, const char* propName) const throw (CMMError);
* void startPropertySequence(const char* label, const char* propName) const throw (CMMError);
* void stopPropertySequence(const char* label, const char* propName) const throw (CMMError);
* long getPropertySequenceMaxLength(const char* label, const char* propName) const throw (CMMError);
* void loadPropertySequence(const char* label, const char* propName, std::vector<std::string> eventSequence) const throw (CMMError);
* bool debugLogEnabled(void) – access the current log state
* std::string saveLogArchive(void)  &    std::string saveLogArchiveWithPreamble(char* preamble, int length)  - create a gzip of the current system log, optionally prepend some client text
* static void addSearchPath(const char *path) – add path to search for device adapters
* unsigned getNumberOfCameraChannels() const – number of simulaneous channels acquired by the camera.
==== Extensions to metadata API ====
* void* getLastImageMD(Metadata& md) const throw (CMMError);
* void* popNextImageMD(Metadata& md) throw (CMMError);
==== Acquisition context API ====
* void acqBefore() throw (CMMError);
* void acqAfter() throw (CMMError);
* void acqBeforeFrame() throw (CMMError);
* void acqAfterFrame() throw (CMMError);
* void acqBeforeStack() throw (CMMError);
* void acqAfterStack() throw (CMMError);
* template <class T> T* getSpecificDevice(const char* deviceLabel) const throw (CMMError) – retrieve device instance by name.

=== API version 33 (1.3.43 release) ===

* New Device categories 
** ProgrammableIO()
** SLM() ( Projector, Spatial Light Modulator, or Anti-Camera)
** CommandDispatch()
* MMDevice.h changes terminology 
* Channels (in the context of color cameras) become Components, hence:
** GetNumberOfChannels -> GetNumberOfComponents. 
** GetChannelName → GetComponentName
* New method signature for devices 
** PrepareSequenceAcqusition()
* Autofocus devices add methods 
** GetOffset(double &offset)
** SetOffset(double offset)
* Core (in MMDevice.h) new method signatures 
** OnCoordinateUpdate(const Device* caller)
** GetChannelConfigs(std::vector<std::string>& groups)
* CMMCore (in MMCore.h) new signatures 
** void setAutoFocusOffset(double offset) throw (CMMError);
** double getAutoFocusOffset() throw (CMMError);
** std::string getSLMDevice();
** std::string getChannelGroup();
** void setSLMDevice(const char* slmLabel) throw (CMMError);
** void setChannelGroup(const char* channelGroup) throw (CMMError);
* CMMCore support for pixel size calibration and configuration group management.

=== API version 31 (1.3.17 release) ===

* BaseSequenceThread. Implemented basic sequence acquisition functionality in svc() method like calculating number of frames, capturing with the specified interval and etc. 

* CCameraBase
** Implemented virtual function IsCapturing returning true if the acquisition thread is run. If you do not use the BaseSequence thread to implement Sequence acquisition, then you will need to provide your own implementation of this function. 
** Added virtual  ThreadRun() method. This method is called from inside the acquisition thread and implements receiving image data from the camera.
** Added virtual OnThreadExiting() method called from inside the acquisition thread and implements actions necessary to finalize the sequence capturing.  

* CMMCore
** Added isSequenceRunning() method which should be used instead of “Busy()” method of the camera to determine if the camera adapter is executing a sequence of image capturing. Note: normally, camera adapters should not return Busy status while the sequence acquisition thread is running.
** Circular buffer now supports 32-bit images.

=== API version 26 to 30 (1.3.15 release) ===
1.	XYStageDevices.  Default implementations for the functions SetRelativePositionUm(double, double), SetPositionUm(double, double), and GetPositionUm(double) are now provided in DeviceBase.h.  You are encouraged not to override these functions but rather implement the Get and SetPostionSteps.  This allows Micro-Manager to provide a general mechanism to let the use mirror the axis and change axis orientation so that a generalized coordinate system can be used.  Although these implementations are not yet provided for single axis stages we anticipate this to happen soon and encourage you to use the 'PositionSteps' functions as the main entry point in communicating with the actual device

2.	CameraDevice – Added Properties 'TransposeMirrorX', 'TransposeMirrorY', 'TransposeXY', 'TranposeCorrection', that can be used to inform Micro-Manager of the camera orientation.  See https://valelab.ucsf.edu/~nico/MMwiki/index.php/Overview for information on how coordinates and directionality are handled in Micro-Manager

3.	CameraDevice – Changes in Sequence mode: There is now a default implementation for SequenceAcquisition.  You should override this with a better implementation if you can.  Two more overloaded forms of StartSequenceAcquistion have been added with default implementations that should b e implemented where possible (one form does not request a number of images, another adds the  parameter bool stopOnOverflow).  

4.	SignalIODevice – Added the functions SetGateOpen and GetGateOpen that are used to configure IO devices as shutters.  

=== API version 24 to 26 (1.2.15 release) ===

1.	CameraDevice - Made the functions 'int GetBinning()' and 'int SetBinning(int binSize)' mandatory.  GetBinning is used in the Core to adjust pixelSize based on binning. The function 'GetNominalPixelSize' was removed.  

2.	StageDevice - Added the function 'int SetRelativePositionUm(double d)'. A default implementation is provided, however, you are encouraged to override this function (which will be madated some time in the future).

3. 	XYStageDevice - Added function 'int SetRelativePositionUm (double dx, double dy)'.  A default implementation is provided, however, you are encouraged to override this function (which will be madated some time in the future).

4.	MagnifierDevice - This is a new device that should be used by devices that effect the magnification in a predictable way.  A single method needs to be implemented for such a device: 'double GetMagnification()'

=== API version 20 to 24 (1.2 release) ===

==== New methods for the base MMDevice class ====
* HasProperty() – for finding out if device supports a property before using it. This will avoid generating and handling exceptions if the desired property does not exist. Default implementation is in the DeviceBase.h, automatic and requires no overriding.
* GetPropertyType() – returns property type. Default implementation is in the DeviceBase.h, automatic and requires no overriding.
* UsesDelay() – Default implementation returns “false”, i.e. declaring that the device does not use “Delay” setting. If the particular adapter does use delay settings, it must override this method by returning “true”. Very few devices use this feature.
* HasPropertyLimits(), GetPropertyLowerLimit(), GetPropertyUpperLimit() – This set of methods allows the device to specify value limits for “continuous” settings. The default implementation of these methods is automatic, but the limits (if any) must be specified in the code when particular property is declared using SetPropertyLimits(). For an example see DemoStreamingCamera.cpp.

==== New device types ====
* ImageStreamer, ImageProcessor and SignalIO device types were added. Instances of these devices are still under development and the API is likely to change. 

We do not recommend writing adapters for these device types just as yet.

=== API version 14 to 20 (1.1 release) ===
New device type
Processor virtual device is added to the MMDevice API to enable real-time processing and closed loop control.
Continuous (burst) acquisition mode
Camera API was extended to optionally support continuous acquisition mode. This mode allows cameras to run at full speed, under their own timing. Additional extensions were also made in the CoreCallback API to provide access to the circular buffer service.
MMTime utility class
A new utility class MMTime was added to simplify cross-platform high-resolution timer functionality, for time-out loops, time stamps, etc.

=== API version 12 to 14 ===
This section is very important if you already have custom adapters for the previous API revision. Your existing adapters won't work with the newer Micro-Manager releases if you don't make changes listed below.
DLL naming convention
All adapter DLL file names now have prefix "mmgr_dal_", e.g. mmgr_dal_hamamatsu.dll. However, there are no changes required for the configuration files. The prefix is internally appended by the MMCore when looking for the device adapter and it does not appear in any external naming convention.

Example project files in this package are all updated with the new convention.  The linker will add prefix to the output file name. You need to modify your existing projects to conform to the new file naming convention.

Additional methods required in all adapter modules
All adapter modules (DLL libraries) now support additional methods (see ModuleInterface.h):

 extern "C" {
    MODULE_API MM::Device* CreateDevice(const char* name);
    MODULE_API void DeleteDevice(MM::Device* pDevice);
    MODULE_API long GetModuleVersion();
    MODULE_API long GetDeviceInterfaceVersion();
    MODULE_API unsigned GetNumberOfDevices();
    MODULE_API bool GetDeviceName(unsigned deviceIndex, char* name, unsigned bufferLength);
    MODULE_API bool GetDeviceDescription(unsigned deviceIndex, char* name, unsigned bufferLength);
    MODULE_API void InitializeModuleData();
 }

The only thing you need to add to your existing modules is the implementation of the method "InitializeModuleData()" (see example projects). This method will be called each time MMCore loads the adapter library. In this method we create a list of adapters available in the DLL library. For example, DemoCamera library (DemoCamera.cpp) has the following InitializeModuleData() method implementation:

 MODULE_API void InitializeModuleData()
 {
    AddAvailableDeviceName(g_CameraDeviceName, "Demo camera");
    AddAvailableDeviceName(g_WheelDeviceName, "Demo filter wheel");
    AddAvailableDeviceName(g_ObjectiveDeviceName, "Demo objective turret");
    AddAvailableDeviceName(g_StageDeviceName, "Demo stage");
    AddAvailableDeviceName(g_LightPathDeviceName, "Demo light path");
 }

The first parameter in "AddAvailableDeviceName", is the adapter name and the second one is a short description.



{{Devices_Sidebar}}
