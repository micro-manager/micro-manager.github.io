The 2.0 API of Micro-Manager is a substantial departure from previous versions. With it, we want to provide access to many aspects of the program that were previously hidden in internal classes. For example, it is now much more straightforward to access acquisition image data, control image display windows, read and modify acquisition metadata, and save data to disk. Additionally, we have rearranged the <code>org.micromanager</code> package. <code>org.micromanager.api</code> has been removed; instead, everything that is ''not'' part of the API has been moved into various "internal" packages (like <code>org.micromanager.internal</code>, <code>org.micromanager.display.internal</code>, etc.). 

The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/ Javadocs] should prove useful to anyone wanting to familiarize themselves with the API. This page provides some more focused and descriptive guidance, with reference to the Javadocs where appropriate.

== Acquisition data: the data API ==

The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/package-frame.html org.micromanager.data] package contains all of the API for reading and manipulating acquisition data. In particular, there are several new classes that you should familiarize yourself with if you want to read, modify, or create acquisition data or metadata.

As a general note, many of the classes (in particular, [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Image.html Image], [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Coords.html Coords], [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Metadata.html Metadata], and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/SummaryMetadata.html SummaryMetadata]) below are immutable. This means that a given instance of the class cannot be modified -- it will have methods to read its state, but no methods to modify them. If you want a modified version of a class, instead you make a copy that is different in the relevant ways. Immutability provides many advantages for ensuring coherency of data in complex workflows. However, it can take some getting used to.

=== The Datastore class ===

[http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html org.micromanager.data.Datastore] is a new class that holds the image data and summary metadata of an acquisition. Every acquisition has an associated Datastore, and you can create your own Datastores to perform custom acquisitions (see the section on the [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html DataManager], below). 

The primary functions you will likely be interested in are:

* [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html#putImage(org.micromanager.data.Image) putImage] and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html#getImage(org.micromanager.data.Coords) getImage], which allow you to add and retrieve Images from the Datastore (see the <code>Image</code> class, below).
* [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html#save(org.micromanager.data.Datastore.SaveMode,%20java.lang.String) save], which saves the contents of the Datastore to disk. There's also [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html#save(org.micromanager.data.Datastore.SaveMode,%20java.awt.Window) a version of the method] that prompts the user for a directory to save to.
* [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html#registerForEvents(java.lang.Object) registerForEvents], which allows you to be notified whenever the data in the Datastore (i.e. the Images or SummaryMetadata) are modified. The Datastore has a <code>com.google.common.eventbus.EventBus</code> that signals events; appropriate methods with the <code>com.google.common.eventbus.Subscribe</code> annotation will be called when the event occurs. For example:

<code>
import com.google.common.eventbus.Subscribe;
import org.micromanager.data.Datastore;
import org.micromanager.data.Image;
import org.micromanager.data.NewImageEvent;
import org.micromanager.Studio;

public class MyClass {
   public MyClass(Studio studio) {
      Datastore myDatastore = studio.data().createRAMDatastore();
      myDatastore.registerForEvents(this);
   }

   @Subscribe
   public void onNewImage(NewImageEvent event) {
      Image newImage = event.getImage();
      // Examine the newly-added image...
   }
}</code>

=== The Image class ===

The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Image.html Image] class replaces the old <code>TaggedImage</code> class as our internal representation of a single 2D, monochromatic image. Where <code>TaggedImage</code> had a <code>JSONObject</code> for all metadata and an <code>Object</code> for the image pixel data, Image has getter methods for:

* The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Metadata.html Metadata] of the image (see below)
* The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Coords.html Coords] of the image, which represent its location within the Datastore.
* The image data itself. As with TaggedImage, this data is available as a raw Object (most likely a <code>byte[]</code> or <code>short[]</code>); however, the Image class can also generate an ImgPlus if you are running in Fiji and want to make use of the ImgLib image manipulation routines.

In addition there are various methods for creating copies of the <code>Image</code> with different metadata or at different coordinates. 

While <code>Image</code> is intended to completely supplant <code>TaggedImage</code>, the latter class is not completely gone; it is still generated by various <code>MMCore</code> functions. You can generate an <code>Image</code> from a <code>TaggedImage</code> by calling the [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#convertTaggedImage(mmcorej.TaggedImage) convertTaggedImage] method of the <code>DataManager</code>, below.

=== [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Metadata.html Metadata] and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/SummaryMetadata.html SummaryMetadata] ===

These classes replace the <code>JSONObject</code> that 1.4 used to store image metadata and acquisition summary metadata. The old system did not enforce any kind of type safety, tended to have redundant and/or vaguely-named entries, and was slow. The new classes have pre-defined supported fields that are strongly-typed, and can be rapidly constructed based on a template metadata object.

Both of these classes (and the [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Coords.html Coords] and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/display/DisplaySettings.html DisplaySettings] classes, discussed later) use a "Builder" pattern to create new instances. See [[Using_Builders]] for more information.

If you have extra fields that you wish to include in the metadata or summary metadata, there is a <code>userData</code> field with the type of [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/PropertyMap.html PropertyMap], which allows for storing semi-arbitrary key-value pairs. You can add whatever fields you like to this object. Micro-Manager itself (the "first-party" code) will not pay any attention to values in that object, but it will preserve them for any third-party code (plugins and scripts) that does.

=== Coords ===

A [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Coords.html Coords] is a location in N-dimensional space. It includes an arbitrary list of axes (represented by strings like "time", "channel", etc.), and a position along each axis. Every [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Image.html Image] has a Coords denoting its position in the [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/Datastore.html Datastore], and every Image's coordinates must be unique. If you attempt to add an Image to a Datastore whose Coords match those of an image that is already in the Datastore, then the old image is replaced by the new one.

You are not restricted to the classic 4 axes of channel, time, z slice, and stage position. You can freely add additional axes and call them whatever you like. The only axis that Micro-Manager treats specially is the channel axis, and then only in the display code. Additionally, you are not required to provide a position along any given axis. If you ask a Coords what its position is for an axis it does not have, it will return -1.

However, please note that Micro-Manager's savefile formats do not support extra axes at this time. Consequently, use of arbitrary axes must be limited to RAM-based Datastores (created with [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#createRAMDatastore() DataManager.createRAMDatastore]). In the future we will add support for saving arbitrary axes to disk.

As with the <code>Metadata</code> and <code>SummaryMetadat</code> classes, <code>Coords</code> are generated using a builder.

<code>
 Coords.CoordsBuilder builder = mm.data().getCoordsBuilder();
 // Convenience functions to set the standard axes
 builder.time(4); // 5th timepoint
 builder.channel(0); // 1st channel
 builder.position("polarization", 2); // Example custom axis

 Coords coords = builder.build();
 int timepoint = coords.getPositionAt(Coords.TIME); // 4
 int polarization = coords.getPositionAt("polarization"); // 2
 int zSlice = coords.getPositionAt(Coords.Z) // -1
</code>

=== The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html DataManager] ===

Because the API only exposes interfaces (i.e. it does not expose concrete implementations of classes), you do not have the ability to directly create new instances of the Datastore, Image, Coords, Metadata, and SummaryMetadata classes. The DataManager provides that functionality for you (via e.g. [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#getCoordsBuilder() getCoordsBuilder], [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#getMetadataBuilder() getMetadataBuilder], and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#getSummaryMetadataBuilder() getSummaryMetadataBuilder]), and also implements some useful utility methods (like [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#convertTaggedImage(mmcorej.TaggedImage) convertTaggedImage], mentioned earlier, and [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/data/DataManager.html#loadData(java.lang.String,%20boolean) loadData] to load data from disk). The DataManager can be accessed via the [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/Studio.html#data() Studio.data()] method, and uses of it are shown in examples above.

== Display controls: the display API ==

The [http://valelab.ucsf.edu/~MM/doc-2.0.0-alpha/mmstudio/org/micromanager/display/package-frame.html display] package contains the API for creating, controlling, and manipulating image display windows. It provides the ability to create new display windows, programatically control them, and listen to certain events they generate when interacted with.

=== DisplayWindow ===

<code>DisplayWindow</code> is the class that all Micro-Manager image display windows implement. Every <code>DisplayWindow</code> is associated with a single <code>Datastore</code>, and displays the images in that store. <code>DisplayWindow</code> exposes a large number of methods for selecting which images are displayed and controlling how they are displayed. For example, the <code>setDisplayedImageTo</code> method takes a <code>Coords</code> object (described above) and changes the displayed image to be the one at the specified coordinates. 

Most of the properties of the display are encompassed by the <code>DisplaySettings</code> object (see below), which can be accessed with <code>getDisplaySettings</code> and changed with <code>setDisplaySettings</code>. 

If you need to perform ImageJ operations on the display, use the <code>getImagePlus</code> method. This will allow you to e.g. draw ROIs. Some properties of the image, like contrast and magnification, can potentially be manipulated both through the <code>ImagePlus</code> and through the <code>DisplaySettings</code>. Where redundancy like this exists, you should always use the <code>DisplaySettings</code>, to ensure that Micro-Manager's program state remains coherent.

An important caveat for ImageJ operations: Micro-Manager's <code>DisplayWindow</code> is no longer an ImageJ <code>ij.gui.StackWindow</code> as it was in the 1.x versions. Micro-Manager strives to maintain backwards compatibility by creating a hidden <code>StackWindow</code> that transparently redirects most calls to the <code>DisplayWindow</code>; this allows plugins and tools to still largely operate as expected. However, direct window manipulations (e.g. changing the window size or position), and possibly other operations, could behave unexpectedly. If you need to find a <code>DisplayWindow</code>, use the <code>DisplayManager.getCurrentWindow()</code> method or the <code>DisplayManager.getDisplays()</code> method. If you need to manipulate a window as a window, use the <code>DisplayWindow.getAsWindow()</code> method.

As with <code>Datastore</code>, each <code>DisplayWindow</code> has a <code>com.google.common.eventbus.EventBus</code>, whose events you can subscribe to using the <code>registerForEvents()</code> method. In particular, you should listen to the <code>RequestToCloseEvent</code> if you want to be notified when the user clicks on the close button of the window. <code>DisplayWindow</code>s cannot close unless their <code>forceClosed()</code> method is called, which must be done by an outside class. If you are not interested in handling this logic, read about <code>DisplayWindow</code> tracking in the <code>DisplayManager</code> section, below.

=== DisplaySettings ===

The <code>DisplaySettings</code> class tracks most aspects of how exactly images are displayed in a particular <code>DisplayWindow</code>. It bears many structural similarities to the <code>Metadata</code> and <code>SummaryMetadata</code> classes described earlier: it is immutable and constructed with a Builder pattern. For example:

<code>
 DisplaySettings.DisplaySettingsBuilder = studio.display().getStandardDisplaySettings();
 // Change the channel names.
 String[] channelNames = new String[] {"DAPI", "GFP", "Cy5"};
 builder.channelNames(channelNames);
 DisplaySettings newSettings = builder.build();
 // Apply the changes to the current display window.
 DisplayWindow curDisplay = studio.display().getCurrentWindow();
 curDisplay.setDisplaySettings(newSettings);
</code>

Whenever the <code>DisplayWindow</code> receives new <code>DisplaySettings</code>, it posts a <code>NewDisplaySettingsEvent</code> on its <code>EventBus</code>. The various controls in the window listen for this event, and automatically update themselves to reflect the new settings. Thus, for example, if you wanted to change the coordinates of the displayed image, you could create a new <code>DisplaySettings</code> with a modified <code>imageCoords</code> field, instead of calling <code>DisplayWindow.setDisplayedImageTo()</code>.

=== DisplayManager ===

The <code>DisplayManager</code> class (accessible via <code>ScriptInterface.display()</code>) performs various tasks that aren't specific to other classes. In particular, as with <code>DataManager</code> above, it provides ways to instantiate objects whose constructors are not exposed in the API: <code>createDisplay()</code> to create a new <code>DisplayWindow</code>, <code>getDisplaySettingsBuilder()</code> to generate a new <code>DisplaySettings.DisplaySettingsBuilder</code>, and <code>getStandardDisplaySettings()</code> to get a copy of the <code>DisplaySettings</code> that the user has set as their saved defaults. It also implements two utility methods to find <code>DisplayWindow</code>s: <code>getCurrentWindow()</code> to return the topmost <code>DisplayWindow</code>, and <code>getAllImageWindows()</code> to return a list of all <code>DisplayWindow</code>s.

==== Tracking ====

In addition to the above, <code>DisplayManager</code> also handles tracking of <code>Datastore</code>s. A "tracked" <code>Datastore</code> will be disposed of when all of its <code>DisplayWindow</code>s go away. Additionally, before the last <code>DisplayWindow</code> is allowed to close, either the <code>Datastore</code> must have saved its data, or the user must have explicitly confirmed closing without saving.

By default, newly-created <code>Datastore</code>s from <code>DataManager.createNewDatastore()</code> are not tracked; thus, you are responsible for ensuring that they are saved, if so desired, as well as calling the <code>forceClosed</code> method of windows that are no longer needed. If you want to transfer this responsibility to Micro-Manager, call the <code>track()</code> method of <code>DisplayManager</code>. It will automatically find all <code>DisplayWindow</code>s associated with the <code>Datastore</code>, and register on their <code>EventBus</code>es. All <code>DisplayWindow</code>s except the last are allowed to close when the user clicks the close button. When the last one tries to close, the <code>DisplayManager</code> will ensure that the user has a chance to save their data.

All <code>Datastore</code>s that Micro-Manager creates for its own purposes (for example, for storing the results of a multi-dimensional acquisition) are automatically tracked.
