The 2.0 API of Micro-Manager is a substantial departure from previous versions. With it, we want to provide access to many aspects of the program that were previously hidden in internal classes. For example, it is now much more straightforward to access acquisition image data, control image display windows, read and modify acquisition metadata, and save data to disk. Additionally, we have rearranged the <code>org.micromanager</code> package. <code>org.micromanager.api</code> has been removed; instead, everything that is ''not'' part of the API has been moved into various "internal" packages (like <code>org.micromanager.internal</code>, <code>org.micromanager.display.internal</code>, etc.). 

This page will break down how the new API works and how to control it.

== Acquisition data: the data API ==

The <code>org.micromanager.data</code> package contains all of the API for reading and manipulating acquisition data. In particular, there are several new classes that you should familiarize yourself with if you want to read, modify, or create acquisition data or metadata.

As a general note, many of the classes (in particular, <code>Image, Coords, Metadata,</code> and <code>SummaryMetadata</code>) below are immutable. This means that a given instance of the class cannot be modified -- it will have methods to read its state, but no methods to modify them. If you want a modified version of a class, instead you make a copy that is different in the relevant ways. Immutability provides many advantages for ensuring coherency of data in complex workflows. However, it can take some getting used to.

=== The Datastore class ===

<code>org.micromanager.data.Datastore</code> is a new class that holds the image data and summary metadata of an acquisition. Every acquisition has an associated Datastore, and you can create your own Datastores to perform custom acquisitions (see the section on the <code>DataManager</code>, below). 

The primary functions you will likely be interested in are:

* <code>putImage</code> and <code>getImage</code>, which allow you to add and retrieve Images from the Datastore (see the <code>Image</code> class, below).
* <code>save</code>, which saves the contents of the Datastore to disk.
* <code>registerForEvents</code>, which allows you to be notified whenever the data in the Datastore (i.e. the Images or SummaryMetadata) are modified. The <code>Datastore</code> has a <code>com.google.common.eventbus.EventBus</code> that it publishes events on; appropriate methods with the <code>com.google.common.eventbus.Subscribe</code> annotation will be called when the event occurs. For example:

<code>
import com.google.common.eventbus.Subscribe;
import org.micromanager.data.Datastore;
import org.micromanager.data.Image;
import org.micromanager.data.NewImageEvent;
import org.micromanager.ScriptInterface;

public class MyClass {
   public MyClass(ScriptInterface studio) {
      Datastore myDatastore = studio.data().createNewDatastore();
      myDatastore.registerForEvents(this);
   }

   @Subscribe
   public void onNewImage(NewImageEvent event) {
      Image newImage = event.getImage();
      // Examine the newly-added image...
   }
}</code>

There are many other functions available in <code>Datastore</code> that you may wish to make use of.

=== The Image class ===

The <code>Image</code> class replaces the old <code>TaggedImage</code> class as our internal representation of a single 2D, monochromatic image. Where <code>TaggedImage</code> had a <code>JSONObject</code> for all metadata and an <code>Object</code> for the image pixel data, Image has getter methods for:

* The <code>Metadata</code> of the image (see below)
* The <code>Coords</code> of the image, which represent its location within the Datastore.
* The image data itself. As with TaggedImage, this data is available as a raw Object (most likely a <code>byte[]</code> or <code>short[]</code>); however, the Image class can also generate an ImgPlus if you are running in Fiji and want to make use of the ImgLib image manipulation routines.

In addition there are various methods for creating copies of the <code>Image</code> with different metadata or at different coordinates. 

While <code>Image</code> is intended to completely supplant <code>TaggedImage</code>, the latter class is not completely gone; it is still generated by the <code>MMCore</code> by various functions. You can generate an <code>Image</code> from a <code>TaggedImage</code> by calling the <code>convertTaggedImage</code> method of the <code>DataManager</code>, below.

=== Metadata and SummaryMetadata ===

These classes replace the <code>JSONObject</code> that we used to use to store image metadata and acquisition summary metadata. The old system did not enforce any kidn of type safety, tended to have redundant and/or poorly-named entries, and was slow. The new classes have pre-defined supported fields that are strongly-typed, and can be rapidly constructed based on a template metadata object.

Both of these classes (and the <code>Coords</code> and <code>DisplaySettings</code> classes, discussed later) use a "Builder" pattern to create new instances. For example:

<code>Metadata.MetadataBuilder builder = gui.data().getMetadataBuilder();
builder.binning(2);
builder.bitDepth(12);
builder.channelName("DAPI");
builder.comments("Test snap with DAPI filter settings");
Metadata metadata = builder.build();</code>

The builder holds the state of the <code>Metadata</code> object in a mutable form. Once <code>builder.build()</code> is called, a new, immutable <code>Metadata</code> instance is created. This example creates a <code>Metadata</code> object with the binning, bit depth, channel name, and comments fields filled out; all other fields will be null. After calling <code>builder.build()</code> above, the builder can be re-used to create a new Metadata object later -- for example, by calling <code>channelName</code> and <code>comments</code> again with different strings, to create a <code>Metadata</code> for a different channel setting. The generated <code>Metadata</code> objects do not have setters, only getters -- so you could call <code>metadata.getBinning()</code> and get 12, for example.

You can also generate a builder from an existing <code>Metadata</code> object (or a <code>SummaryMetadata</code>, etc.) by using its <code>copy()</code> method. For example, the below code would create a new <code>Image</code> from an existing one, with an updated comment:

<code>Metadata.MetadataBuilder builder = image.getMetadata().copy();
builder.comment("Updated comment for this image");
Metadata newMetadata = builder.build();
image = image.copyWithMetadata(newMetadata);</code>

The builder generated by the <code>copy</code> method is pre-populated with all of the fields of its source <code>Metadata</code> object, so you don't have to manually set them all.

If you have extra fields that you wish to include in the metadata or summary metadata, there is a <code>userData</code> field that takes a JSONObject. You can add whatever fields you like to this object, but you won't benefit from the type-safety that the <code>Metadata</code> and <code>SummaryMetadata</code> classes provide.

=== Coords ===

A Coords is a location in N-dimensional space. It includes an arbitrary list of axes (represented by strings like "time", "channel", etc.), and a position along each axis. Every <code>Image</code> has a <code>Coords</code> denoting its position in the <code>Datastore</code>, and every <code>Image</code>'s coordinates must be unique.

You are not restricted to the classic 4 axes of channel, time, z slice, and stage position. You can freely add additional axes and call them whatever you like. The only axis that Micro-Manager treats specially is the channel axis, and then only in the display code. Additionally, you are not required to provide a position along any given axis. If you ask a Coords what its position is for an axis it does not have, it will return -1.

As with the <code>Metadata</code> and <code>SummaryMetadat</code> classes, <code>Coords</code> are generated using a builder:

<code>Coords.CoordsBuilder builder = gui.data().getCoordsBuilder();
// Convenience functions to set the standard axes
builder.time(4); // 5th timepoint
builder.channel(0); // 1st channel
builder.position("polarization", 2); // Example custom axis

Coords coords = builder.build();
int timepoint = coords.getPositionAt(Coords.TIME); // 4
int polarization = coords.getPositionAt("polarization"); // 2
int zSlice = coords.getPositionAt(Coords.Z) // -1</code>

However, there is an important caveat with current versions of Micro-Manager 2.x: only the classic four axes are preserved when <code>Datastore</code> is saved to disk. We will rectify this in future.

=== The DataManager ===

Because the API only exposes interfaces (i.e. it does not expose concrete implementations of classes), you do not have the ability to directly create new instances of the <code>Datastore, Image, Coords, Metadata</code>, and <code>SummaryMetadata</code> classes. The <code>DataManager</code> provides that functionality for you, and also implements some useful utility methods (like <code>convertTaggedImage</code>, mentioned earlier, as well as access to the current "album" <code>Datastore</code>). It can be accessed via the <code>org.micromanager.ScriptInterface.data()</code> method, and uses of it are shown in examples above.

== Display controls: the display API ==

The <code>org.micromanager.display</code> package contains the API for creating, controlling, and manipulating image display windows. It provides the ability to create new display windows, programatically control them, and listen to certain eventns they generate when interacted with.

=== DisplayWindow ===

<code>DisplayWindow</code> is the class that all Micro-Manager image display windows implement. Every <code>DisplayWindow</code> is associated with a single <code>Datastore</code>, and displays the images in that store. <code>DisplayWindow</code> exposes a large number of methods for selecting which images are displayed and controlling how they are displayed. For example, the <code>setDisplayedImageTo</code> method takes a <code>Coords</code> object (described above) and changes the displayed image to be the one at the specified coordinates. 

Most of the properties of the display are encompassed by th. <code>DisplaySettings</code> object (see below), which can be accessed with <code>getDisplaySettings</code> and changed with <code>setDisplaySettings</code>. 

If you need to perform ImageJ operations on the display, use the <code>getImagePlus</code> method. This will allow you to e.g. draw ROIs. Some properties of the image, like contrast and magnification, can potentially be manipulated both through the <code>ImagePlus</code> and through the <code>DisplaySettings</code>. Where redundancy like this exists, you should always use the <code>DisplaySettings</code>, to ensure that Micro-Manager's program state remains coherent.

An important caveat for ImageJ operations: Micro-Manager's <code>DisplayWindow</code> is no longer an ImageJ <code>ij.gui.StackWindow</code> as it was in the 1.x versions. Micro-Manager strives to maintain backwards compatibility by creating a hidden <code>StackWindow</code> that transparently redirects most calls to the <code>DisplayWindow>; this allows plugins and tools to still largely operate as expected. However, direct window manipulations (e.g. changing the window size or position), and possibly other operations, could behave unexpectedly. If you need to find a <code>DisplayWindow</code>, use the <code>DisplayManager.getCurrentWindow()</code> method or the <code>DisplayManager.getDisplays()</code> method. If you need to manipulate a window as a window, use the <code>DisplayWindow.getAsWindow()</code> method.

As with <code>Datastore</code>, each <code>DisplayWindow</code> has a <code>com.google.common.eventbus.EventBus</code>, whose events you can subscribe to using the <code>registerForEvents()</code> method. In particular, you should listen to the <code>RequestToCloseEvent</code> if you want to be notified when the user clicks on the close button of the window. <code>DisplayWindow</code>s cannot close unless their <code>forceClosed()</code> method is called, which must be done by an outside class. If you are not interested in handling this logic, read about <code>DisplayWindow</code> tracking in the <code>DisplayManager</code> section, below.

=== DisplaySettings ===

The <code>DisplaySettings</code> class tracks most aspects of how exactly images are displayed in a particular <code>DisplayWindow</code>. It bears many structural similarities to the <code>Metadata</code> and <code>SummaryMetadata</code> classes described earlier: it is immutable and constructed with a Builder pattern. For example:

<code>DisplaySettings.DisplaySettingsBuilder = studio.display().getStandardDisplaySettings();
// Change the channel names.
String[] channelNames = new String[] {"DAPI", "GFP", "Cy5"};
builder.channelNames(channelNames);
DisplaySettings newSettings = builder.build();
// Apply the changes to the current display window.
DisplayWindow curDisplay = studio.display().getCurrentWindow();
curDisplay.setDisplaySettings(newSettings);</code>

Whenever the <code>DisplayWindow</code> receives new <code>DisplaySettings</code>, it posts a <code>NewDisplaySettingsEvent</code> on its <code>EventBus</code>. The various controls in the window listen for this event, and automatically update themselves to reflect the new settings. Thus, for example, if you wanted to change the coordinates of the displayed image, you could create a new <code>DisplaySettings</code> with a modified <code>imageCoords</code> field, instead of calling <code>DisplayWindow.setDisplayedImageTo()</code>. 

=== DisplayManager ===

The <code>DisplayManager</code> class (accessible via <code>ScriptInterface.display()</code>) performs various tasks that aren't specific to other classes. In particular, as with <code>DataManager</code> above, it provides ways to instantiate objects whose constructors are not exposed in the API: <code>createDisplay()</code> to create a new <code>DisplayWindow</code>, <code>getDisplaySettingsBuilder()</code> to generate a new <code>DisplaySettings.DisplaySettingsBuilder</code>, and <code>getStandardDisplaySettings()</code> to get a copy of the <code>DisplaySettings</code> that the user has set as their saved defaults. It also implements two utility methods to find <code>DisplayWindow</code>s: <code>getCurrentWindow()</code> to return the topmost <code>DisplayWindow</code>, and <code>getAllImageWindows()</code> to return a list of all <code>DisplayWindow</code>s.

==== Tracking ====

In addition to the above, <code>DisplayManager</code> also handles tracking of <code>Datastore</code>s. A "tracked" <code>Datastore</code> will be disposed of when all of its <code>DisplayWindow</code>s go away. Additionally, before the last <code>DisplayWindow</code> is allowed to close, either the <code>Datastore</code> must have saved its data, or the user must have explicitly allowed closing without saving.

By default, newly-created <code>Datastore</code>s from <code>DataManager.createNewDatastore()</code> are not tracked; thus, you are responsible for ensuring that they are saved, if so desired, as well as calling the <code>forceClosed</code> method of windows that are no longer needed. If you want to transfer this responsibility to Micro-Manager, call the <code>track()</code> method of <code>DisplayManager</code>. It will automatically find all <code>DisplayWindow</code>s associated with the <code>Datastore</code>, and register on their <code>EventBus</code>es. All <code>DisplayWindow</code>s except the last are allowed to close when the user clicks the close button. When the last one tries to close, the <code>DisplayManager</code> will ensure that the user has a chance to save their data.

All <code>Datastore</code>s that Micro-Manager creates for its own purposes (for example, for storing the results of a multi-dimensional acquisition) are automatically tracked.
