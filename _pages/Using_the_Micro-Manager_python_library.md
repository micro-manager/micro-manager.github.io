---
autogenerated: true
title: Using the Micro-Manager python library
layout: page
section: Programming
---

The easiest way to control Micro-Manager through Python is the
[Pycro-manager](https://github.com/micro-manager/pycro-manager) library.

The instructions below are for an alternative mechanism in which you
compile the micro-manager core yourself with python bindings.

**MMCorePy** is a wrapper that allows you to control microscope hardware
from python interactive session or script. It's support Windows, Mac and
Linux.

Micromanager's main parts:

-   CMMCore - basic module, written in C++. Script languages like python
    just wrap it by [swig](http://www.swig.org).
-   Device adapters - various libraries that allow support for various
    hardware. If you want to built one and extend MM devise support,
    follow [this
    guide](Building_Micro-Manager_Device_Adapters "wikilink").
-   MMCorePy - python wrapper. MM build scripts are support both python
    2 and 3, but windows version still ships with python 2 bindings
    only.
-   MMCoreJ - java wrapper
-   MMStudio - Micromanager GUI (technically it is ImageJ plugin).

## Environment setup

You must install python2 and numpy. Windows users may prefer using an
python distribution instead manual separate installation.

### Manual

-   [python 2.7.x](http://python.org/) (python2 is default for windows
    now)
-   [numpy 1.7.x](http://scipy.org/) Micromanager represent imaging data
    as multidimensional numpy arrays.

### Using python distributions

It's convenient to install a distribution which includes Python, numpy,
scientific libraries, GUI frameworks and IDEs. All distributions have a
free version, some of them have extended paid version, and you can
request free academic license.

-   [Enthought's python distribution
    (EPD)](https://www.enthought.com/products/epd/free/)
-   [Anaconda](http://continuum.io/downloads), has package manager.
-   [PythonXY](https://code.google.com/p/pythonxy) totally free.

### Useful libraries

-   Scipy - scientific algorithms, multidimensional image processing
    toolbox.
-   Matplotlib - fastest way to show your image data.
-   Opencv - computer vision and image processing library. Sometimes
    faster than scipy.
-   Pillow - very basic image processing. Scipy uses it for image
    loading and writing.
-   Scikit-image - "pythonic" scientific-oriented image processing
    algorithms collection.
-   [IPython](http://ipython.org/) - improved interactive python
    environment

## Micromanager installation

### Windows & Mac

[Download](Download_Micro-Manager_Latest_Release "wikilink") and install
Micro-Manager on your computer. Add Micromanager installation folder to
[PYTHONPATH](https://docs.python.org/2/using/cmdline.html#envvar-PYTHONPATH)
(i.e. "*C:\\Program Files\\Micro-Manager-1.4*", it should contain
<small>*MMCorePy.py*</small> and <small>*\_MMCorePy.pyd*</small> files).
Create variable if it not exist. At now you can import MMCorePy without
an error.

### Linux

MM package from your distribution repository, in most cases, ships with
CMMCore, MMCorePy (python 2 or 3 wrapper) and MMCoreJ, but without GUI.
Python and Numpy would be installed by your package manager as
dependency. In normal way, you don't need changing any system variable.

## Using Python API

Familiarize yourself with Micro-Manager and learn how to connect it to
your hardware by MMStudio GUI.

-   Find your device on [this page](Device_Support "wikilink") and
    figure out what adapter you need.
-   [Micro-Manager Configuration
    Guide](Micro-Manager_Configuration_Guide "wikilink") help you to
    understand how properties work.
-   Read the general [Micro-Manager Programming
    Guide](Micro-Manager_Programming_Guide "wikilink")
-   Use
    [API](https://valelab.ucsf.edu/~MM/doc/MMCore/html/class_c_m_m_core.html).

### First steps

&lt;INCLUDE Note text="Next code snippets aims to be most generic. We
use numpy and matplotlib "as is" from pure python interactive shell, but
it's convenient to use IPython with nice autocompletion
capabilities.ðŸ˜Ž"&gt;

Start python interactive session. Import \`MMCorePy\` and make sure
everything is working properly.

```
Â Â Â >>>Â importÂ MMCorePy
Â Â Â >>>Â mmcÂ =Â MMCorePy.CMMCore()Â Â #Â InstanceÂ micromanagerÂ core
Â Â Â >>>Â mmc.getVersionInfo()
Â Â Â 'MMCoreÂ versionÂ 2.3.2'
Â Â Â >>>Â mmc.getAPIVersionInfo()
Â Â Â 'DeviceÂ APIÂ versionÂ 59,Â ModuleÂ APIÂ versionÂ 10'
```

We just get some basic information about current Micromanager
installation. If there an \`ImportError\`, check your PYTHONPATH
variable. If output is too verbose, run
<small>mmc.enableStderrLog(False); mmc.enableDebugLog(False)</small>.

### Device loading

{% include Note text="You can get all needed parameter's names from Micromanager configuration file, generated by MMStudio." %}

Let's take step closer to hardware. Micromanager have couple of dummy
devices, suitable for learning purposes. Load DemoCamera:

```
Â Â Â #Â DemoÂ cameraÂ example,Â continuationÂ ofÂ previousÂ listing
Â Â Â >>>Â mmc.loadDevice('Camera',Â 'DemoCamera',Â 'DCam')
Â Â Â >>>Â mmc.initializeAllDevices()
Â Â Â >>>Â mmc.setCameraDevice('Camera')
```

### Property discovery

Every device has
[properties](Micro-Manager_User's_Guide#Exploring_devices:_Device.2FProperty_Browser "wikilink")
- settings that let you control the device more precisely. Default
values should be fine, but if you need something sophisticated, [this
example](https://github.com/radioxoma/micromanager-samples/blob/master/mm_print_properties.py)
help you figure out how to explore it.

### Snapping single image

Images returned as numpy array by calls to an instance of the pythonized
Micro-Manager
[CMMCore](https://valelab.ucsf.edu/~MM/doc/MMCore/html/class_c_m_m_core.html)
class. The array <small>dtype</small> depends on property named
*PixelType* (see below).

#### Grayscale

```
Â Â Â >>>Â mmc.snapImage()
Â Â Â >>>Â imgÂ =Â mmc.getImage()Â Â #Â imgÂ -Â it'sÂ justÂ numpyÂ array
Â Â Â >>>Â img
Â Â Â array([[12,Â 12,Â 13,Â ...,Â 11,Â 12,Â 12],
Â Â Â Â Â Â Â Â Â Â [12,Â 12,Â 13,Â ...,Â 11,Â 12,Â 12],
Â Â Â Â Â Â Â Â Â Â [12,Â 13,Â 13,Â ...,Â 12,Â 12,Â 12],
Â Â Â Â Â Â Â Â Â Â ...,
Â Â Â Â Â Â Â Â Â Â [22,Â 22,Â 22,Â ...,Â 22,Â 22,Â 22],
Â Â Â Â Â Â Â Â Â Â [22,Â 22,Â 22,Â ...,Â 22,Â 22,Â 22],
Â Â Â Â Â Â Â Â Â Â [22,Â 22,Â 22,Â ...,Â 22,Â 22,Â 22]],Â dtype=uint8)
```

DemoCamera snaps grayscale 8-bit image, by default. It presented as
two-dimensional numpy array. Let's show image data with matplotlib.

```
Â Â Â >>>Â importÂ matplotlib.pyplotÂ asÂ plt
Â Â Â >>>Â plt.imshow(img,Â cmap='gray')
Â Â Â >>>Â plt.show()Â Â #Â AndÂ windowÂ willÂ appear
```

#### Color

Of course, color image is more suitable for optical microscopy purposes.
So take one, if your camera support it:

```
Â Â Â >>>Â mmc.setProperty('Camera',Â 'PixelType',Â '32bitRGB')Â Â #Â ChangeÂ pixelÂ type
Â Â Â >>>Â rgb32Â =Â mmc.getImage()
Â Â Â >>>Â rgb32
Â Â Â array([[1250067,Â 1250067,Â 1315860,Â ...,Â 1250067,Â 1250067,Â 1250067],
Â Â Â Â Â Â Â Â Â Â [1250067,Â 1315603,Â 1315860,Â ...,Â 1250067,Â 1250067,Â 1250067],
Â Â Â Â Â Â Â Â Â Â [1250067,Â 1315859,Â 1315860,Â ...,Â 1250067,Â 1250067,Â 1250067],
Â Â Â Â Â Â Â Â Â Â ...,
Â Â Â Â Â Â Â Â Â Â [1246483,Â 1246483,Â 1246483,Â ...,Â 1181204,Â 1246740,Â 1246484],
Â Â Â Â Â Â Â Â Â Â [1246483,Â 1246483,Â 1246483,Â ...,Â 1246740,Â 1246740,Â 1246483],
Â Â Â Â Â Â Â Â Â Â [1246483,Â 1246483,Â 1312019,Â ...,Â 1246740,Â 1246740,Â 1246483]],Â dtype=uint32)
```

Interesting output isn't it? We expect something like 3-dimensional RGB
array, but get bunch of 32-bit uints in 2-D shape.

#### Numpy array

Now we should look at RGB32 pixel data structure. Every pixel has 32-bit
depth and contain 4 values for blue, green, red and blank channel. Blank
channel is more technical peculiarity, than necessity.

```
lowÂ memoryÂ addressÂ Â Â Â ---->Â Â Â Â Â Â highÂ memoryÂ address
|Â pixelÂ |Â pixelÂ |Â pixelÂ |Â pixelÂ |Â pixelÂ |Â pixelÂ |...
|-------|-------|-------|-------|-------|-------|...
|B|G|R|A|B|G|R|A|B|G|R|A|B|G|R|A|B|G|R|A|B|G|R|A|...
```

[http://avisynth.nl/index.php/RGB32](http://avisynth.nl/index.php/RGB32)

Let's numpy handle that.

```
>>>Â importÂ numpyÂ asÂ np
>>>Â rgb32.shape
(512,Â 512)
>>>Â rgbÂ =Â rgb32.view(dtype=np.uint8).reshape(
Â Â Â Â Â Â Â Â rgb32.shape[0],Â rgb32.shape[1],Â 4)[...,2::-1]
>>>Â rgb.shape
(512,Â 512,Â 3)
>>>Â rgb.dtype
dtype('uint8')
```

It is a fastest way to get pixel data as RGB array without copying.
There is no conversion - just creating new view to same data. Now you
can process image with scipy or scikits-image. Note, that opencv uses
BGR order (replace slice to `[..., :3]` for that).

### Continuous acquisition

{% include Warning text="'''Don't run this code directly.''' It's a partial sample." %}

```
mmc.startContinuousSequenceAcquisition(1)
whileÂ True:
Â Â Â Â ifÂ mmc.getRemainingImageCount()Â >Â 0:
Â Â Â Â Â Â Â Â frameÂ =Â mmc.getLastImage()
Â Â Â Â Â Â Â Â #Â orÂ frameÂ =Â mmc.popNextImage()
```

### Code examples

A longer example script,
[MMCoreWrapDemo.py](https://github.com/mdcurtis/micromanager-upstream/blob/master/bindist/any-platform/MMCoreWrapDemo.py),
is available in the Micro-Manager root directory.

Also check out [micromanager-samples
repo](https://github.com/radioxoma/micromanager-samples) (live video
acquisition, property discovery etc).

## Further reading

-   [Image manipulation and processing using Numpy and
    Scipy](http://scipy-lectures.github.io/advanced/image_processing/index.html)
    by Python Scientific Lecture Notes.
-   [Scikits-image
    gallery](http://scikit-image.org/docs/dev/auto_examples)
-   [Lectures on scientific computing with
    Python](https://github.com/jrjohansson/scientific-python-lectures)
-   [OpenCV-Python
    Tutorials](http://docs.opencv.org/trunk/doc/py_tutorials/py_tutorials.html)

Written by Eugene Dvoretsky -- [Radioxoma](User:Radioxoma "wikilink")
([talk](User_talk:Radioxoma "wikilink")) 09:19, 14 June 2014 (PDT)

