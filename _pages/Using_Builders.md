---
autogenerated: true
title: Using Builders
layout: page
---

This is a guide to using the Builder pattern, which is used extensively
in the Micro-Manager 2.0 API for creating objects like image coordinates
and metadata.

### Overview

Let's use the `Metadata` class as an example. This class describes the
metadata for a single image in Micro-Manager. Below is a simplified
extract from the interface definition, with only five properties:

```
publicÂ interfaceÂ MetadataÂ {Â 
Â Â Â interfaceÂ MetadataBuilderÂ {
Â Â Â Â Â Â MetadataÂ build();

Â Â Â Â Â Â MetadataBuilderÂ bitDepth(IntegerÂ bitDepth);
Â Â Â Â Â Â MetadataBuilderÂ channelName(StringÂ channelName);
Â Â Â Â Â Â MetadataBuilderÂ exposureMs(DoubleÂ exposureMs);
Â Â Â Â Â Â MetadataBuilderÂ pixelSizeUm(DoubleÂ pixelSizeUm);
Â Â Â Â Â Â MetadataBuilderÂ userData(PropertyMapÂ userData);
Â Â Â }

Â Â Â MetadataBuilderÂ copy();

Â Â Â DoubleÂ getExposureMs();
Â Â Â DoubleÂ getPixelSizeUm();
Â Â Â IntegerÂ getBitDepth();
Â Â Â PropertyMapÂ getUserData();
Â Â Â StringÂ getChannelName();
}
```

There are two classes: the Metadata itself, and the Builder for the
Metadata. Note that the Metadata does not have any methods that *change*
it: it is impossible to modify a Metadata instance after it is created
(the Metadata is "immutable"). Instead, a Builder is created, and *it*
can be modified (for justification of why these objects are immutable,
see the bottom of the page). However, properties of the Builder cannot
be *read*, so it isn't very useful on its own. To generate a Metadata
from the Builder, you use the `build` method. For example:

```
Metadata.MetadataBuilderÂ builderÂ =Â mm.data().getMetadataBuilder();
//Â CreateÂ metadataÂ forÂ firstÂ image.
builderÂ =Â builder.bitDepth(14).exposureMs(100);
MetadataÂ metadata1Â =Â builder.build();
intÂ exposure1Â =Â metadata1.getExposureMs();Â //Â willÂ beÂ 100
//Â CreateÂ metadataÂ forÂ secondÂ image:Â onlyÂ exposureÂ timeÂ change
builderÂ =Â builder.exposureMs(80);
MetadataÂ metadata2Â =Â builder.build();
IntegerÂ exposure2Â =Â metadata2.getExposureMs();Â //Â willÂ beÂ 80
DoubleÂ pixelSizeÂ =Â metadata2.getPixelSizeUm();Â //Â willÂ beÂ null!
//Â Don'tÂ doÂ this:Â itÂ wouldÂ throwÂ aÂ NullPointerException:
//Â doubleÂ pixelSizeÂ =Â metadata2.getPixelSizeUm();
```

There's a few things to call your attention to here:

-   Since every method on a Builder except the `build()` method returns
    the Builder, you can chain those methods together to set several
    properties in a single statement.
-   The Builder object can be re-used to generate multiple Metadata
    instances with only minor variations.
-   Any properties *not* set in the Builder will also not be set in the
    Metadata. In this case, that means that the values are null. It is
    important that you use the "boxed" objects like `Integer`, `Double`,
    and `Boolean` when accessing properties of a Metadata, as opposed to
    using `int`, `double`, or `boolean`. The latter will throw a
    `NullPointerException` if you try to assign a null to them.

In addition to using a "raw" Builder object to construct new Metadata
objects, you can also ask a Metadata object for a Builder that's based
on it, using the `copy()` method. The above example code could
equivalently be written as:

```
Metadata.MetadataBuilderÂ builderÂ =Â mm.data().createMetadataBuilder();
//Â CreateÂ metadataÂ forÂ firstÂ image.
builderÂ =Â builder.bitDepth(14).exposureMs(100);
MetadataÂ metadata1Â =Â builder.build();
//Â CreateÂ metadataÂ forÂ secondÂ image:Â onlyÂ channelÂ nameÂ andÂ exposureÂ timeÂ change
MetadataÂ metadata2Â =Â metadata1.copy().exposureMs(80).build();
```

This can be useful in situations where you don't have access to the
original Builder.

### Variations

The above example was specific to the Metadata class. There are some
variations for other Micro-Manager 2.0 objects, which are covered here.

#### Coords

Coords objects are very similar to Metadata objects. They have a set of
convenience functions for commonly-used coordinate axes:
`channel`, `time`, `z`, and `stagePosition`. They also use the `int`
datatype to represent coordinates, and thus cannot use `null` to
indicate a missing value like Metadata does. Instead, missing values are
represented by -1.

Here is an example of creating a new Coords object:

```
Coords.CoordsBuilderÂ builderÂ =Â mm.data().getCoordsBuilder();
//Â NoteÂ thatÂ coordinatesÂ startÂ countingÂ fromÂ 0!
//Â ThusÂ thisÂ imageÂ willÂ beÂ theÂ secondÂ channel,Â 5thÂ ZÂ slice.
builder.channel(1).z(4);
//Â YouÂ canÂ alsoÂ setÂ customÂ axes.
builder.index("polarization",Â 3);
CoordsÂ coordsÂ =Â builder.build();
coords.getChannel();Â //Â 1
coords.getZ();Â //Â 4
coords.getTime();Â //Â -1Â asÂ noÂ timeÂ valueÂ wasÂ set
coords.getIndex("polarization");Â //Â 3
CoordsÂ coords2Â =Â coords.copy().z(5).build();
coords2.getZ();Â //Â 5
coords2.getIndex("polarization");Â //Â 3
```

#### Images

Images do not have Builder objects because they are comparatively
simple: they consist of a pixel data array, some parameters that are
required to interpret that array, the Coords describing the image's
location, and a Metadata instance. You can use the DataManager to create
a new Image directly:

```
ImageÂ imageÂ =Â mm.data().createImage(pixels,Â width,Â height,Â bytesPerPixel,
Â Â Â Â Â Â numComponents,Â coords,Â metadata);
```

(See the documentation on the DataManager for more information on these
parameters)

You can also create a new Image from an existing Image by varying its
coordinates, metadata, or both:

```
ImageÂ copy1Â =Â image.copyAtCoords(newCoords);
ImageÂ copy2Â =Â image.copyWithMetadata(newMetadata);
ImageÂ copy3Â =Â image.copyWith(newCoords,Â newMetadata);
```

Thus for example, if you wanted to change the location of an image prior
to adding it to a Datastore, you could do the following:

```
DatastoreÂ storeÂ =Â mm.data().createRAMDatastore();
//Â SnapÂ anÂ image;Â thisÂ imageÂ willÂ haveÂ incorrectÂ coordinates
ImageÂ origImageÂ =Â mm.live().snap(false).get(0);
//Â FixÂ theÂ coordinates.
Coords.CoordsBuilderÂ builderÂ =Â mm.data().getCoordsBuilder();
CoordsÂ coordsÂ =Â builder.channel(1).z(4).build();
ImageÂ newImageÂ =Â origImage.copyAtCoords(coords);
store.putImage(newImage);
```

### Why immutability

Making objects immutable is a common technique used to simplify data
handling in complex programs, especially multithreaded ones.

At first glance it would seem like making objects that you aren't
allowed to modify just makes your life a lot more complicated. And it is
true that there are a few more steps to follow to create a modified
Metadata than there would be if you could just modify the Metadata
in-place. However, the fact that these objects are immutable is vital
for Micro-Manager's image workflows, because it means that no piece of
code has to worry about an object being changed "out from under it".

Without that guarantee, it is impossible for code to guarantee
consistency. For example, if an image's metadata says it's for the Cy5
channel, then nobody can change that image to say it's actually for the
DAPI channel instead. Code can create a *new* image that is identical
except for its channel, but that new image does not replace the old one
anywhere else (it's a new reference).

Imagine you have a plugin that saves images to different files depending
on their channels, and some third-party code changes the channel string
while you're running. Depending on exactly when the string changes, an
image might end up in a different file! Making images immutable
guarantees that you will never have this problem; if the third-party
code wants that image to be in a different channel, then it will create
a new image, while you will still have the old one.

#### Isn't this horribly inefficient?

All this copying whenever you want to make a change seems like it would
be very inefficient. Fortunately this isn't the case. When you make a
"copy" of, say, an Image, all you are copying is the *references* to the
image's data, not that data itself. For example, if the original Image
and the new Image only differ in their coordinates, then they will
"share" image pixel data and Metadata, and only have different Coords
objects. This holds true within Metadata and SummaryMetadata as well: if
you create a new Metadata by copying an existing one and changing just
the channel name, then the new and old objects will share everything
else.

Consequently, copying an object is an extremely cheap action. The
immutability guarantee actually allows us to use *less* memory than we
would have to if objects were mutable, because it allows two objects
that are very similar to share their resources.

&lt;INCLUDE 2.0\_Sidebar text="ğŸ˜"&gt;
