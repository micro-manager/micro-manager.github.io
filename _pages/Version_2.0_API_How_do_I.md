---
autogenerated: true
title: Version 2.0 API How do I
layout: page
---

This page covers how to accomplish many common tasks with the
Micro-Manager 2.0 API. It is intended to be a migration assistant for
people familiar with the 1.4 API, and a getting-started guide for those
who have never written Micro-Manager control code before.

In the below examples, reference will be made to an `mm` object. This is
the Studio interface for Micro-Manager's java layer. It's available as
"mm" by default in the Scripting Panel of Micro-Manager, hence the name.

For clarity, the types returned by the function calls are included. The
Beanshell environment in the Script Panel does not know all these types.
You can either import those types explicitly, e.g.

`importÂ org.micromanager.data.Datastore;`

or you can leave out the type altogether.

This page makes use of many objects that are more fully described in the
[main 2.0 API
documentation](https://micro-manager.org/wiki/Version_2.0_API).

How do I...

### Snap an image?

If you just want to snap an image and have it pop up in the viewer, then
you want to access the `SnapLiveManager` object:

`importÂ java.util.List;`  
`ListÂ imagesÂ =Â mm.live().snap(true);`

The boolean value passed in will tell the SnapLiveManager that you want
to see the images that were snapped; the returned List of Image objects
is the images acquired. There will only be multiple images if you're
using a multi-camera setup.

### Display an image?

If you have an Image object - for instance, by snapping one:

`imagesÂ =Â mm.live().snap(false);`  
`imageÂ =Â images.get(0);`

and you want to create a new display window and display it, you can use
the `DisplayManager` object:

`DatastoreÂ storeÂ =Â mm.displays().show(image);`

This will create a new Datastore and DisplayWindow, add the image to the
Datastore, and return it. You can then add new images to the Datastore
(using `Datastore.putImage(image)`) and they will also be displayed in
the window.

### Access image data and metadata?

If you have data in an open window that you want to access, you can
readily do that through the `DisplayManager` interface:

`DatastoreÂ storeÂ =Â mm.displays().getCurrentWindow().getDatastore();`

The above code will retrieve the topmost `DisplayWindow` and then
extract the `Datastore` that contains the data that the `DisplayWindow`
presents.

From there, you can request images via their `Coords`:

`Coords.CoordsBuilderÂ builderÂ =Â mm.data().getCoordsBuilder();`  
`builderÂ =Â builder.z(2).time(5).channel(1).stagePosition(0);`  
`CoordsÂ coordsÂ =Â builder.build();`  
`ImageÂ imageÂ =Â store.getImage(coords);`

You can access the image's `Metadata`:

`importÂ org.micromanager.data.Metadata;`

`MetadataÂ metadataÂ =Â image.getMetadata();`  
`DoubleÂ exposureÂ =Â metadata.getExposureMs();`

You can access the dataset's `SummaryMetadata` as a whole:

`importÂ org.micromanager.data.SummaryMetadata;`  
`SummaryMetadataÂ summaryÂ =Â store.getSummaryMetadata();`  
`String[]Â channelsÂ =Â summary.getChannelNames();`

If the dataset has not been frozen, then you can modify it, for example
by adding new images:

`importÂ java.util.List;`  
`ListÂ newImagesÂ =Â mm.live().snap(false);`  
`ImageÂ newImageÂ =Â newImages.get(0);`  
`newImageÂ =Â newImage.copyAtCoords(coords.copy().time(6).build());`  
`store.putImage(newImage);`

### Control live mode?

As above, you want the `SnapLiveManager` object. You can ask if live
mode is on or off using:

`booleanÂ isOnÂ =Â mm.live().getIsLiveModeOn();`

And you can turn live mode on or off with:

`mm.live().setLiveMode(isOn);`

For example, `mm.live().setLiveMode(false)` would turn live mode off,
regardless of whether or not it was currently on.

If you need to temporarily halt live mode to perform some action (for
example, changing the ROI of a camera that can't change ROIs
mid-acquisition), but want to restore live mode to the state it was in
after you have performed that action, then you can suspend live mode:

`mm.live().setSuspended(true);`  
`...performÂ someÂ action...`  
`mm.live().setSuspended(false);`

If live mode is on, then it will turn off when you call
`setSuspended(true)`, and it will re-start when you call
`setSuspended(false)`. If live mode was off, then it will remain off.

### Run an acquisition using the MDA settings?

You have two similar options here:

`mm.acquisitions().runAcquisition();`

and

`mm.acquisitions().runAcquisition(StringÂ name,Â StringÂ root);`

Both will run an acquisition using the current MDA settings; the latter
method will also allow you to specify where data should be saved. Both
methods return a `Datastore` that contains the acquired images.

Note also this method:

`mm.acquisitions().loadAcquisition(StringÂ path);`

This method allows you to load a previously-saved set of acquisition
settings, automatically populating the fields in the MDA dialog. You can
create one of these acquisition settings files via the "Save as..."
button in the MDA dialog.

### Manually perform an acquisition?

Probably the simplest way to do this is to can snap images using the
SnapLiveManager, and display them using a DisplayWindow, while adjusting
other hardware properties (like the stage position or illumination
source) by talking to the Core. By changing the coordinates of the
images, you can create a timeseries, Z-stack, multi-channel, et cetera
dataset.

`importÂ java.util.List;`  
`importÂ org.micromanager.data.Coords;`  
`importÂ org.micromanager.data.Datastore;`  
`importÂ org.micromanager.data.Image;`

`//Â AÂ RAMÂ datastoreÂ storesÂ allÂ ofÂ itsÂ imagesÂ onÂ RAM,Â notÂ onÂ theÂ hardÂ drive.`  
`//Â ThereÂ areÂ otherÂ optionsÂ asÂ describedÂ inÂ theÂ DataManagerÂ documentation.`  
`DatastoreÂ storeÂ =Â mm.data().createRAMDatastore();`  
`//Â CreateÂ aÂ displayÂ forÂ theÂ datastore.Â ThisÂ won'tÂ actuallyÂ showÂ upÂ untilÂ there`  
`//Â areÂ imagesÂ toÂ see,Â though.`  
`mm.displays().createDisplay(store);`

`//Â SnapÂ anÂ image.Â Don'tÂ displayÂ itÂ inÂ theÂ snap/liveÂ display.`  
`ListÂ imagesÂ =Â mm.live().snap(false);`  
`//Â Let'sÂ assumeÂ forÂ nowÂ thatÂ weÂ aren'tÂ usingÂ aÂ multi-cameraÂ setup,Â soÂ the`  
`//Â aboveÂ listÂ onlyÂ hasÂ oneÂ element.`  
`ImageÂ imageÂ =Â images.get(0);`  
`//Â SetÂ theÂ timeÂ andÂ channelÂ indicesÂ forÂ thisÂ image.Â CoordinateÂ axesÂ thatÂ you`  
`//Â don'tÂ careÂ aboutÂ canÂ beÂ leftÂ alone.`  
`Coords.CoordsBuilderÂ builderÂ =Â mm.data().getCoordsBuilder();`  
`builderÂ =Â builder.time(0).channel(0);`  
`imageÂ =Â image.copyAtCoords(builder.build());`  
`store.putImage(image);`

`//Â SnapÂ anotherÂ image.`  
`imageÂ =Â mm.live().snap(false).get(0);`  
`//Â PutÂ itÂ asÂ theÂ nextÂ channel.`  
`builderÂ =Â builder.channel(1);`  
`imageÂ =Â image.copyAtCoords(builder.build());`  
`store.putImage(image);`

`//Â SaveÂ theÂ datastore.`  
`StringÂ savePathÂ =Â "pathÂ toÂ whereÂ youÂ wantÂ toÂ saveÂ data";`  
`store.save(Datastore.SaveMode.MULTIPAGE_TIFF,Â savePath);`

### Control the core?

The MMCore is the same as it's always been, so methods for setting
hardware properties, snapping images, manually running sequences, etc.
are unchanged. You can access the core via

`mm.core()`

or

`mm.getCMMCore()`

\<INCLUDE 2.0\_Sidebar text="ğŸ˜"\>
