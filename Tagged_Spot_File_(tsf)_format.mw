== Description of  tagged spot file format (.tsf) ==

Nico Stuurman, April 3, 2013.

The goal of the tagged post file format is to provide an efficient data format for superresolution microscopy data that generate images by locating the position of single fluorescent emitters.  Two formats exists, a binary format (using Google protocol buffers) and a text format.  An application is free to  upport only one or the other, but is encouraged to support both.

=== Binary format. ===
  

The binary format relies on Google Protocol buffers ([http://code.google.com/apis/protocolbuffers/]) to encode data. Two message types are defined, “SpotList”, which contains metadata concerning the dataset, and “Spot”, which contains the per-spot data.  For convenience, a copy of the proto file describing these messages is included at the bottom of the document, however, the authorative version resides at: [https://valelab.ucsf.edu/svn/valelabtools/TSFProto].

Note that you can extend the TSF.proto file yourself and add fields that you need for your specific application.  The file created with your proto file can still be read by all other software that reads the tagged spot file format (although it will not be able to interpret the fields that you added).  

All message sizes and file offsets are of type signed int or signed long (to ensure compatibility with Java code)

=== File layout on disk: ===

'''int magic (4 bytes)''' - must be 0 (this is for compatibility with older versions of the tsf format)

'''long SpotList offset (8 bytes)''' - offset in bytes to SpotList message (note, this is the offset from the beginning of the file minus 12 bytes).

As many copies of the message “Spot” as desired, where

'''int length (4 bytes)''' - Size of the Spot message

'''Spot message'''

The Spot messages are followed by the SpotList message:

'''int length (4 bytes)''' - Size of SpotList message

'''SpotList message'''

The reason for putting the SpotList message at the end is that this makes it possible to write all the Spot data first and then include in the SpotList the number of Spots that have been written.  Code that reads the file can first read the SpotList (using the SpotList offset) and will then know how many Spot messages to expect.  Note that it is not necessary to know this number in advance, one can simply parse Spot messages until no more new ones are found.

===  Building and/or using the code ===


To use the tsf format in your own code, you need Java or C++ source code to work with the tsf format.  This source code is created by the Google Protocol Buffers binary based on the TSF.proto file.  You can create this source code yourself by downloading and installing Google Protocol Buffers and compiling the the TSF.proto file.  To do so, I use the following script (Mac OS X shell script):

<code>
protoc -I=src/ --java_out=build src/TSFProto.proto
javac -sourcepath build -classpath dist/gproto.jar build/edu/ucsf/tsf/TaggedSpotsProtos.java
jar cf dist/TSFProto.jar -C build .
protoc -I=src/ --cpp_out=buildcpp src/TSFProto.proto
g++ -c buildcpp/TSFProto.pb.cc -o buildcpp/libTSFProto.o
ar cru buildcpp/libTSFPProto.a buildcpp/TSFProto.o /usr/local/lib/libprotobuf.a</code>

Alternatively, you can download and install the source code that I build.  It resides in a subversion repository at: [https://valelab.ucsf.edu/svn/valelabtools/TSFProto/].  The Java source code is in directory “build”, the C++ source code in directory “buildcpp”.

The following (pseudo Java) code shows how you can read in a file in TSF format:

<code>
        FileInputStream fi = new FileInputStream(selectedFile);
        DataInputStream di = new DataInputStream(fi);

        // the file has an initial 0, then the offset (as long)
        // to the position of spotList
        int magic = di.readInt();
        long offset = di.readLong();
        fi.skip(offset);
        edu.ucsf.tsf.TaggedSpotsProtos.SpotList psl = SpotList.parseDelimitedFrom(fi);
        fi.close();


        // psl contains the header information
        // the following code shows examples how to use it   

        String name = psl.getName();
        int width = psl.getNrPixelsX();
        int height = psl.getNrPixelsY();
        float pixelSizeUm = psl.getPixelSize();
        long totalSpots = psl.getNrSpots();
        long maxNrSpots = 0;

         // now read the messages that contain the spot data
         // Re-open the stream

         fi = new FileInputStream(selectedFile);
         fi.skip(12); // size of int + size of long

         // simple example of reading Spot messages.
         // One could also store the Spots as an Array or List
         // and access the Spot data directly in the code (i.e., use
         // the Spot message as a native data structure

         edu.ucsf.tsf.TaggedSpotsProtos.SpotSpot pSpot;

         while (fi.available() > 0 && (expectedSpots == 0 || totalSpots < expectedSpots)) {

             pSpot = Spot.parseDelimitedFrom(fi);
             double x = pSpot.getXPosition();
             double y = pSpot.getYposition();
             double in = pSpot.getIntensity();
             if (pSpot.hasZ()) {
                 double zc = getZ();            
             }

             totalSpots++;
         }
         fi.close();
</code>
